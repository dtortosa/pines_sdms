
R version 3.4.3 (2017-11-30) -- "Kite-Eating Tree"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> ###########################################
> ############ VARIABLE SELECTION ###########
> ###########################################
> 
> ## Load ranked variables based on deviance, which is the % of variance explained of each variable for each species according to a glm and the deviance formula of Weisberg 1980; Guisan & Zimmermann 2000. For further information see "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/code/variables/variable_selection/species_clustering/species_clustering.R".
> d2_rank = read.csv("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/code/variables/variable_selection/species_clustering/clustering_results/d2_rank_species_variables.csv", header=TRUE)
> str(d2_rank)
'data.frame':	113 obs. of  27 variables:
 $ species: Factor w/ 113 levels "albicaulis","amamiana",..: 1 3 2 4 5 6 7 8 9 10 ...
 $ bio1   : int  3 8 11 13 2 3 16 7 5 17 ...
 $ bio10  : int  7 22 15 25 15 11 26 18 8 20 ...
 $ bio11  : int  1 5 9 7 1 2 9 3 2 14 ...
 $ bio12  : int  21 19 8 9 12 24 24 23 11 9 ...
 $ bio13  : int  18 18 4 24 23 16 21 16 16 18 ...
 $ bio14  : int  23 15 3 14 4 5 17 6 15 4 ...
 $ bio15  : int  14 9 7 26 26 7 15 2 18 26 ...
 $ bio16  : int  15 16 5 22 22 17 22 17 14 16 ...
 $ bio17  : int  22 17 2 11 3 9 19 8 13 3 ...
 $ bio18  : int  24 14 13 12 8 22 20 24 10 8 ...
 $ bio19  : int  17 20 1 8 14 21 13 19 17 7 ...
 $ bio2   : int  19 2 22 10 25 14 23 11 12 23 ...
 $ bio3   : int  5 1 10 3 9 1 5 1 1 1 ...
 $ bio4   : int  6 3 6 2 7 4 4 5 7 2 ...
 $ bio5   : int  10 25 18 23 10 15 25 22 4 10 ...
 $ bio6   : int  4 4 16 6 6 6 8 4 3 12 ...
 $ bio7   : int  9 7 21 4 11 10 6 9 9 6 ...
 $ bio8   : int  8 12 20 21 20 12 18 13 20 22 ...
 $ bio9   : int  2 6 24 15 5 8 14 10 6 19 ...
 $ carbon : int  16 10 25 16 18 13 12 12 19 13 ...
 $ cec    : int  11 11 26 18 21 18 11 15 22 24 ...
 $ clay   : int  12 13 12 1 24 19 1 14 23 25 ...
 $ depth  : int  26 26 14 20 16 25 2 26 24 11 ...
 $ ph     : int  25 21 19 19 19 23 10 25 21 15 ...
 $ sand   : int  20 23 17 5 17 26 3 20 25 21 ...
 $ silt   : int  13 24 23 17 13 20 7 21 26 5 ...
> 
> ## create per variable : i) Sumatory of the rakings; ii) Number of species for whicht the variable is the top1,2 or 3.
> ranks_compare = as.data.frame(matrix(NA, ncol=5, nrow=1))
> colnames(ranks_compare) <- c("variable", "sum_rank", "number_ones", "number_twoes", "number_threes")
> for(i in 2:ncol(d2_rank)){ #for each variable (first column is species names)
+     
+     #select the [i] variable
+     selected_col = d2_rank[,i]
+     
+     #selcte the name of the [i] varaiable
+     variable =  colnames(d2_rank)[i]
+     
+     #sum the ranks of the [i] variable across species
+     sum_rank = sum(selected_col)
+ 
+     #calculate the umber of species for whicht the variable is the top1,2 or 3.
+     number_ones = length(which(selected_col == 1))
+     number_twoes = length(which(selected_col == 2))
+     number_threes = length(which(selected_col == 3)) 
+ 
+     #bind all   
+     ranks_compare = rbind.data.frame(ranks_compare, 
+             cbind.data.frame(variable, sum_rank, number_ones, number_twoes, number_threes))
+ }
> 
> #delete row with NAs
> ranks_compare = ranks_compare[-1,]
> 
> #check all variables are included
> nrow(ranks_compare) == length(colnames(d2_rank)[which(!colnames(d2_rank) == "species")])
[1] TRUE
> 
> #set variable names in a vector and long variable names in another vector to add long vname variables to ranks_compare (variable will be the variable to merge)
> variable = c(
+     "bio1", 
+     "bio2", 
+     "bio3", 
+     "bio4", 
+     "bio5", 
+     "bio6", 
+     "bio7", 
+     "bio8", 
+     "bio9", 
+     "bio10",
+     "bio11",
+     "bio12",
+     "bio13",
+     "bio14",
+     "bio15",
+     "bio16",
+     "bio17",
+     "bio18",
+     "bio19",
+     "clay", 
+     "silt", 
+     "sand", 
+     "ph",   
+     "cec",  
+     "carbon",
+     "depth")
> long_var_names = c(
+     "Annual Mean Temperature",
+     "Mean Diurnal Range (Mean of monthly (max temp - min temp))",
+     "Isothermality (BIO2/BIO7) (* 100)",
+     "Temperature Seasonality (standard deviation *100)",
+     "Max Temperature of Warmest Month",
+     "Min Temperature of Coldest Month",
+     "Temperature Annual Range (BIO5-BIO6)",
+     "Mean Temperature of Wettest Quarter",
+     "Mean Temperature of Driest Quarter",
+     "Mean Temperature of Warmest Quarter",
+     "Mean Temperature of Coldest Quarter",
+     "Total (annual) moisture",
+     "Moisture of Wettest Month",
+     "Moisture of Driest Month",
+     "Moisture Seasonality (Coefficient of Variation)",
+     "Moisture of Wettest Quarter",
+     "Moisture of Driest Quarter",
+     "Moisture of Warmest Quarter",
+     "Moisture of Coldest Quarter",
+     "Clay content (\\%)",
+     "Silt content (\\%)",
+     "Sand content (\\%)",
+     "Ph (index * 10)",
+     "Cation-exchange capacity (CEC; cmolc/kg)",
+     "Organic carbon (g/kg)",
+     "Absolute depth to bedrock (cm)")
> 
> #bind them
> var_names = cbind.data.frame(variable, long_var_names)
> 
> #merge the long names with the ranks_compare data.frame
> ranks_compare = merge(var_names, ranks_compare, by = "variable")
> 
> #order the rows in basis on sum_rank (increasing -> first most explicative variables)
> ranks_compare = ranks_compare[order(ranks_compare$sum_rank, decreasing=FALSE),]
> ranks_compare
   variable                                             long_var_names sum_rank
14     bio4          Temperature Seasonality (standard deviation *100)      635
13     bio3                          Isothermality (BIO2/BIO7) (* 100)      724
3     bio11                        Mean Temperature of Coldest Quarter      791
16     bio6                           Min Temperature of Coldest Month      868
17     bio7                       Temperature Annual Range (BIO5-BIO6)      954
1      bio1                                    Annual Mean Temperature     1098
9     bio17                                 Moisture of Driest Quarter     1208
6     bio14                                   Moisture of Driest Month     1342
19     bio9                         Mean Temperature of Driest Quarter     1357
22     clay                                         Clay content (\\%)     1397
4     bio12                                    Total (annual) moisture     1477
11    bio19                                Moisture of Coldest Quarter     1482
26     silt                                         Silt content (\\%)     1725
25     sand                                         Sand content (\\%)     1741
10    bio18                                Moisture of Warmest Quarter     1758
15     bio5                           Max Temperature of Warmest Month     1773
2     bio10                        Mean Temperature of Warmest Quarter     1815
12     bio2 Mean Diurnal Range (Mean of monthly (max temp - min temp))     1850
20   carbon                                      Organic carbon (g/kg)     1852
8     bio16                                Moisture of Wettest Quarter     1864
18     bio8                        Mean Temperature of Wettest Quarter     1872
5     bio13                                  Moisture of Wettest Month     1895
24       ph                                            Ph (index * 10)     1906
7     bio15            Moisture Seasonality (Coefficient of Variation)     1972
23    depth                             Absolute depth to bedrock (cm)     2099
21      cec                   Cation-exchange capacity (CEC; cmolc/kg)     2208
   number_ones number_twoes number_threes
14          11           11            13
13          16           10            16
3           12           11            12
16           0            2             9
17          13            7             5
1            6            6            10
9            3            5             8
6            4            5             3
19           6            9             4
22          26            6             2
4            2            0             1
11           1            6             3
26           0            0             2
25           0           10             9
10           0            1             1
15           2            2             2
2            1            0             3
12           2            2             2
20           1            1             0
8            1            4             3
18           0            1             1
5            3            3             3
24           0            1             1
7            1            2             0
23           2            8             0
21           0            0             0
> 
> #save results
> write.table(ranks_compare, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/ranks_compare.csv", sep=",", row.names = FALSE, col.names = TRUE)
> 
> ##TABLE 1
> #version of sum rank for the paper
> table_1 = ranks_compare[c(which(ranks_compare$variable %in% paste("bio", 1:11, sep="")), which(ranks_compare$variable %in% paste("bio", 12:19, sep="")), which(!ranks_compare$variable %in% paste("bio", 1:19, sep=""))), c(1:3)] #separate temperature, humidity and soil variables, but remains the order of ranks inside each group.
> colnames(table_1)[1] <- "Bioclim abbreviations"
> colnames(table_1)[2] <- "Variables"
> colnames(table_1)[3] <- "Sum of ranks"
> 
> #reorder columns
> table_1 = table_1[,c(2,1,3)]
> 
> #change to mayusculas bio abreviatures and remove soil name variables from columns abbreviature
> new_abreviations = NULL
> for(i in 1:nrow(table_1)){
+     selected_row = table_1[i,]
+ 
+     if(startsWith(as.vector(selected_row$"Bioclim abbreviations"), "bio")){
+         new_abreviations = append(new_abreviations, paste("BIO", strsplit(as.vector(selected_row$"Bioclim abbreviations"), split="bio")[[1]][2], sep=""))
+     } else { 
+         new_abreviations = append(new_abreviations, NA)
+     }
+     print(paste(as.vector(new_abreviations[i]), "--", as.vector(selected_row$"Bioclim abbreviations"), sep=""))
+ }
[1] "BIO4--bio4"
[1] "BIO3--bio3"
[1] "BIO11--bio11"
[1] "BIO6--bio6"
[1] "BIO7--bio7"
[1] "BIO1--bio1"
[1] "BIO9--bio9"
[1] "BIO5--bio5"
[1] "BIO10--bio10"
[1] "BIO2--bio2"
[1] "BIO8--bio8"
[1] "BIO17--bio17"
[1] "BIO14--bio14"
[1] "BIO12--bio12"
[1] "BIO19--bio19"
[1] "BIO18--bio18"
[1] "BIO16--bio16"
[1] "BIO13--bio13"
[1] "BIO15--bio15"
[1] "NA--clay"
[1] "NA--silt"
[1] "NA--sand"
[1] "NA--carbon"
[1] "NA--ph"
[1] "NA--depth"
[1] "NA--cec"
> table_1$"Bioclim abbreviations" <- new_abreviations
> table_1
                                                    Variables
14          Temperature Seasonality (standard deviation *100)
13                          Isothermality (BIO2/BIO7) (* 100)
3                         Mean Temperature of Coldest Quarter
16                           Min Temperature of Coldest Month
17                       Temperature Annual Range (BIO5-BIO6)
1                                     Annual Mean Temperature
19                         Mean Temperature of Driest Quarter
15                           Max Temperature of Warmest Month
2                         Mean Temperature of Warmest Quarter
12 Mean Diurnal Range (Mean of monthly (max temp - min temp))
18                        Mean Temperature of Wettest Quarter
9                                  Moisture of Driest Quarter
6                                    Moisture of Driest Month
4                                     Total (annual) moisture
11                                Moisture of Coldest Quarter
10                                Moisture of Warmest Quarter
8                                 Moisture of Wettest Quarter
5                                   Moisture of Wettest Month
7             Moisture Seasonality (Coefficient of Variation)
22                                         Clay content (\\%)
26                                         Silt content (\\%)
25                                         Sand content (\\%)
20                                      Organic carbon (g/kg)
24                                            Ph (index * 10)
23                             Absolute depth to bedrock (cm)
21                   Cation-exchange capacity (CEC; cmolc/kg)
   Bioclim abbreviations Sum of ranks
14                  BIO4          635
13                  BIO3          724
3                  BIO11          791
16                  BIO6          868
17                  BIO7          954
1                   BIO1         1098
19                  BIO9         1357
15                  BIO5         1773
2                  BIO10         1815
12                  BIO2         1850
18                  BIO8         1872
9                  BIO17         1208
6                  BIO14         1342
4                  BIO12         1477
11                 BIO19         1482
10                 BIO18         1758
8                  BIO16         1864
5                  BIO13         1895
7                  BIO15         1972
22                  <NA>         1397
26                  <NA>         1725
25                  <NA>         1741
20                  <NA>         1852
24                  <NA>         1906
23                  <NA>         2099
21                  <NA>         2208
> 
> #save table as excel
> write.table(table_1, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/code/variables/variable_selection/species_clustering/table_1_paper.csv", sep=",", col.names=TRUE, row.names=FALSE)
> 
> #convert to a latex table
> require(xtable)
Loading required package: xtable
> print.xtable(xtable(table_1, align="lllc"), include.rownames=FALSE, NA.string="", floating = FALSE, sanitize.text.function=function(x) {x}, hline.after=c(-1, 0, 11, 19, 26)) #hline.after add a hline after the indicated row. 
% latex table generated in R 3.4.3 by xtable 1.8-2 package
% Mon Aug  6 19:07:16 2018
\begin{tabular}{llc}
  \hline
Variables & Bioclim abbreviations & Sum of ranks \\ 
  \hline
Temperature Seasonality (standard deviation *100) & BIO4 & 635 \\ 
  Isothermality (BIO2/BIO7) (* 100) & BIO3 & 724 \\ 
  Mean Temperature of Coldest Quarter & BIO11 & 791 \\ 
  Min Temperature of Coldest Month & BIO6 & 868 \\ 
  Temperature Annual Range (BIO5-BIO6) & BIO7 & 954 \\ 
  Annual Mean Temperature & BIO1 & 1098 \\ 
  Mean Temperature of Driest Quarter & BIO9 & 1357 \\ 
  Max Temperature of Warmest Month & BIO5 & 1773 \\ 
  Mean Temperature of Warmest Quarter & BIO10 & 1815 \\ 
  Mean Diurnal Range (Mean of monthly (max temp - min temp)) & BIO2 & 1850 \\ 
  Mean Temperature of Wettest Quarter & BIO8 & 1872 \\ 
   \hline
Moisture of Driest Quarter & BIO17 & 1208 \\ 
  Moisture of Driest Month & BIO14 & 1342 \\ 
  Total (annual) moisture & BIO12 & 1477 \\ 
  Moisture of Coldest Quarter & BIO19 & 1482 \\ 
  Moisture of Warmest Quarter & BIO18 & 1758 \\ 
  Moisture of Wettest Quarter & BIO16 & 1864 \\ 
  Moisture of Wettest Month & BIO13 & 1895 \\ 
  Moisture Seasonality (Coefficient of Variation) & BIO15 & 1972 \\ 
   \hline
Clay content (\%) &  & 1397 \\ 
  Silt content (\%) &  & 1725 \\ 
  Sand content (\%) &  & 1741 \\ 
  Organic carbon (g/kg) &  & 1852 \\ 
  Ph (index * 10) &  & 1906 \\ 
  Absolute depth to bedrock (cm) &  & 2099 \\ 
  Cation-exchange capacity (CEC; cmolc/kg) &  & 2208 \\ 
   \hline
\end{tabular}
> 
> ## Selected variables
> #-Selección de variables: He usado dos criterios: i) La sumatoria de la posición en el deviance ranking de una variable para todas las especies (más alto indica menos explicativo); ii) Número de especies para las que esa variable está en la posición 1,2 ó 3. Me gusta más el primero, porque tiene peso tanto las especies para las que explica mucho como para las que explica poco, por ejmplo: Una variable puede ser el top1 para muchas especies, pero para el resto no explicar nada, ese sería el caso de clay, que es la variable más explicativa para más especies (26), pero luego su suma de los rankings es el doble respecto de la primera variable (explica poco para muchas especies). Por tanto, la sumatoria de los rankings sería lo más idóneo para seleccionar una variable que se va a usar para reconstruir el estado de TODAS las especies.
>     #-Temperatura -> bio4 (Temperature Seasonality). La sumatoria de los rankings es 635 frente a 724 de bio3 (Isothermality), que es la segunda variable más alta de todas. bio3 es el top1,2,3 para más especies (5), pero hay una diferencia considerable en la sumatoria. bio4 se usó para el cluster 3 y 4, mientras que la otras no se usó para ninguno. Además son variables muy parecidas, así que me quedo con la primera según la sumatoria del rank. 
>     #-Humedad -> bio17 (humedad del cuarto más seco). Sumatoria de 1208 frente a los 1342 de bio14 (humedad del mes más seco), que es la segunda variable de humedad más alta. En cuanto al número de especies para las que son el top, están muy igualadas. bio17 se usó para el cluster 2 y 3, la otra para ninguno. además son muy parecidas. Me quedo con bio17, que es la que tiene la sumatoria de nrakings más alta.
>     #-Nota: la info sobre las variables usadas para cada cluster está en "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/code/variables/variable_selection/variable_selection_inside_clusters/variable_selection_inside_clusters.R".
> 
> #################################################################
> ############ EXTRACT P50 AND SE OF CLIMATIC VARIABLES ###########
> #################################################################
> 
> #required packages
> require(raster)
Loading required package: raster
Loading required package: sp
> 
> #list species
> list_species = read.table("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/code/presences/species.txt", sep="\t", header=T)
> str(list_species)
'data.frame':	112 obs. of  1 variable:
 $ genus.specific_epithet: Factor w/ 112 levels "Pinus albicaulis",..: 1 2 3 4 5 6 7 8 9 10 ...
> summary(list_species)
      genus.specific_epithet
 Pinus albicaulis:  1       
 Pinus amamiana  :  1       
 Pinus aristata  :  1       
 Pinus arizonica :  1       
 Pinus armandii  :  1       
 Pinus attenuata :  1       
 (Other)         :106       
> 
> #extract epithet from species list
> epithet_species_list = NULL
> for(i in 1:nrow(list_species)){
+ 
+     #selected species
+     selected_species = as.vector(list_species[i,])
+ 
+     #extract epithet
+     epithet_species_list = append(epithet_species_list, strsplit(selected_species, split=" ")[[1]][2])
+ }
> summary(is.na(epithet_species_list)) #all false
   Mode   FALSE 
logical     112 
> 
> #drop discolor (problem tazonomy, no diferetiaced from cembriodes)
> if("discolor" %in% epithet_species_list){
+     epithet_species_list = epithet_species_list[-which(epithet_species_list == "discolor")]
+ }
> 
> #check it
> !"discolor" %in% epithet_species_list
[1] TRUE
> length(epithet_species_list) == 112
[1] TRUE
> 
> #function to calculate SE
> se <- function(x) sd(x)/sqrt(length(x))
> 
> if(FALSE){
+ #unzip the selected variables bio4 and bio17
+ unzip("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/datos/finals.zip", files = c("finals/bio4.asc", "finals/bio17.asc"), list=FALSE, exdir = "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/datos/phlyo/climatic_data_phylo", junkpaths = TRUE) #junkpaths = TRUE indicated that we don't want all directoy and subdirectories, only the files. 
+ 
+ ####################
+ ##### bio4 #########
+ ####################
+ bio4 = raster("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/datos/phlyo/climatic_data_phylo/bio4.asc")
+ res(bio4)
+ 
+ #Extract bio4 from species distribution
+ require(raster)
+ median_bio4 = NULL
+ sd_bio4 = NULL
+ se_bio4 = NULL
+ bio4_pines = stack() 
+ for (i in 1:length(epithet_species_list)){
+ 
+     #select the species
+     selected_epithet = epithet_species_list[i]
+ 
+     #unzip species distribution with buffer
+     buffer_path = unzip("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/ocurrences.zip",  list=FALSE, exdir = "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/datos/phlyo/buffers", files = paste("ocurrences/", selected_epithet, "_distribution_buffer.asc", sep=""), junkpaths = TRUE)
+ 
+     #load it
+     distri = raster(buffer_path)
+ 
+     #create a polygon from distributon
+     polygon = rasterToPolygons(distri, fun=function(x){x==1}, n=16) #esta funcion de raster te transforma un raster completo o una parte del mismo en un poliogno. En nuestro caso solo queremos las celdas con valor=1, es decir, presencias. Por eso ponemos x==1. 
+ 
+     #crop bio4
+     bio4_cropped = mask(bio4, polygon)
+ 
+     #save the raster in the empty stack
+     bio4_pines = stack(bio4_pines, bio4_cropped) 
+     names(bio4_pines)[i] <- paste("bio4_", selected_epithet, sep="")
+ 
+     #extract humidity data and calculate the median
+     median_bio4 = append(median_bio4, median(na.omit(getValues(bio4_cropped))))
+ 
+     #extract sd
+     sd_value = sd(na.omit(getValues(bio4_cropped)))
+ 
+     #extract se
+     se_value = sd_value/sqrt(length(na.omit(getValues(bio4_cropped))))
+ 
+     #save both of them
+     sd_bio4 = append(sd_bio4, sd_value)
+     se_bio4 = append(se_bio4, se_value)
+ }
+ 
+ #check that that data from all species has been extracted
+ nlayers(bio4_pines) == 112 #112, on for each species
+ length(median_bio4) == 112
+ length(sd_bio4) == 112
+ length(se_bio4) == 112
+ 
+ #check that species names are ok
+ paste("bio4_", epithet_species_list, sep="") == names(bio4_pines)
+ 
+ #bind species names and medians
+ medians_bio4 = cbind.data.frame(epithet_species_list, median_bio4)
+ colnames(medians_bio4) <- c("species", "median_bio4")
+ 
+ #bind species and ranges
+ standard_dev_bio4 = cbind.data.frame(epithet_species_list, sd_bio4)
+ colnames(standard_dev_bio4) <- c("species", "sd_bio4")
+ standard_error_bio4 = cbind.data.frame(epithet_species_list, se_bio4)
+ colnames(standard_error_bio4) <- c("species", "se_bio4")
+ 
+ #save medians
+ write.table(medians_bio4, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_medians/medians_bio4.csv", sep=",", col.names = TRUE, row.names = FALSE)
+ 
+ #save sd
+ write.table(standard_dev_bio4, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_ranges/sd_bio4.txt", sep="\t", col.names = TRUE, row.names = FALSE)
+ 
+ #save se
+ write.table(standard_error_bio4, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_ranges/se_bio4.txt", sep="\t", col.names = TRUE, row.names = FALSE)
+ 
+ #save rasters
+ #writeRaster(bio4_pines, filename="/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/datos/phlyo/climatic_data_phylo/bio4_buffer.tif", options="INTERLEAVE=BAND", overwrite=TRUE)
+ 
+ 
+ 
+ ####################
+ ##### bio17 ########
+ ####################
+ bio17 = raster("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/datos/phlyo/climatic_data_phylo/bio17.asc")
+ res(bio17)
+ 
+ #Extract bio17 from species distribution
+ require(raster)
+ median_bio17 = NULL
+ sd_bio17 = NULL
+ se_bio17 = NULL
+ bio17_pines = stack() 
+ for (i in 1:length(epithet_species_list)){
+ 
+     #select the species
+     selected_epithet = epithet_species_list[i]
+ 
+     #unzip species distribution with buffer
+     buffer_path = unzip("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/ocurrences.zip",  list=FALSE, exdir = "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/datos/phlyo/buffers", files = paste("ocurrences/", selected_epithet, "_distribution_buffer.asc", sep=""), junkpaths = TRUE)
+ 
+     #load it
+     distri = raster(buffer_path)
+ 
+     #create a polygon from distributon
+     polygon = rasterToPolygons(distri, fun=function(x){x==1}, n=16) #esta funcion de raster te transforma un raster completo o una parte del mismo en un poliogno. En nuestro caso solo queremos las celdas con valor=1, es decir, presencias. Por eso ponemos x==1. 
+ 
+     #crop bio17
+     bio17_cropped = mask(bio17, polygon)
+ 
+     #save the raster in the empty stack
+     bio17_pines = stack(bio17_pines, bio17_cropped) 
+     names(bio17_pines)[i] <- paste("bio17_", selected_epithet, sep="")
+ 
+     #extract humidity data and calculate the median
+     median_bio17 = append(median_bio17, median(na.omit(getValues(bio17_cropped))))
+ 
+     #extract sd
+     sd_value = sd(na.omit(getValues(bio17_cropped)))
+ 
+     #extract se
+     se_value = sd_value/sqrt(length(na.omit(getValues(bio17_cropped))))
+ 
+     #save both of them
+     sd_bio17 = append(sd_bio17, sd_value)
+     se_bio17 = append(se_bio17, se_value)
+ }
+ 
+ #check that that data from all species has been extracted
+ nlayers(bio17_pines) == 112 #112, on for each species
+ length(median_bio17) == 112
+ length(se_bio17) == 112
+ length(sd_bio17) == 112
+ 
+ #check that species names are ok
+ paste("bio17_", epithet_species_list, sep="") == names(bio17_pines)
+ 
+ #bind species names and clim data 
+ medians_bio17 = cbind.data.frame(epithet_species_list, median_bio17)
+ colnames(medians_bio17) <- c("species", "median_bio17")
+ 
+ #bind species and ranges
+ standard_dev_bio17 = cbind.data.frame(epithet_species_list, sd_bio17)
+ colnames(standard_dev_bio17) <- c("species", "sd_bio17")
+ standard_error_bio17 = cbind.data.frame(epithet_species_list, se_bio17)
+ colnames(standard_error_bio17) <- c("species", "se_bio17")
+ 
+ #save medians
+ write.table(medians_bio17, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_medians/medians_bio17.csv", sep=",", col.names = TRUE, row.names = FALSE)
+ 
+ #save sd
+ write.table(standard_dev_bio17, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_ranges/sd_bio17.txt", sep="\t", col.names = TRUE, row.names = FALSE)
+ 
+ #save se
+ write.table(standard_error_bio17, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_ranges/se_bio17.txt", sep="\t", col.names = TRUE, row.names = FALSE)
+ 
+ #save rasters
+ #writeRaster(bio17_pines, filename="/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/datos/phlyo/climatic_data_phylo/bio17_buffer.tif", options="INTERLEAVE=BAND", overwrite=TRUE)
+ }
> 
> #########################################
> ##### bind both variables of p50 ########
> #########################################
> 
> #load bio4 p50 data
> medians_bio4 = read.table("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_medians/medians_bio4.csv", sep=",", header=TRUE)
> 
> #load bio17 p50 data
> medians_bio17 = read.table("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_medians/medians_bio17.csv", sep=",", header=TRUE)
> 
> #merge
> climate_medians = merge(medians_bio4, medians_bio17, by="species")
> 
> #save
> write.table(climate_medians, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_medians/climate_medians.csv", col.names = TRUE, row.names = FALSE, sep=",") 
> write.table(climate_medians, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_medians/climate_medians.txt", col.names = TRUE, row.names = FALSE, sep="\t") 
> 
> 
> #########################################
> ##### bind both variables of ranges ########
> #########################################
> 
> #sd
> sd_bio4 = read.table("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_ranges/sd_bio4.txt", sep="\t", header=TRUE)
> sd_bio17 = read.table("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_ranges/sd_bio17.txt", sep="\t", header=TRUE)
> 
> #se
> se_bio4 = read.table("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_ranges/se_bio4.txt", sep="\t", header=TRUE)
> se_bio17 = read.table("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_ranges/se_bio17.txt", sep="\t", header=TRUE)
> #merge
> climate_sd = merge(sd_bio4, sd_bio17, by="species")
> climate_se = merge(se_bio4, se_bio17, by="species")
> 
> #save
> #sd
> write.table(climate_sd, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_ranges/climate_sd.csv", col.names = TRUE, row.names = FALSE, sep=",") 
> write.table(climate_sd, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_ranges/climate_sd.txt", col.names = TRUE, row.names = FALSE, sep="\t") 
> #se
> write.table(climate_se, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_ranges/climate_se.csv", col.names = TRUE, row.names = FALSE, sep=",") 
> write.table(climate_se, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_ranges/climate_se.txt", col.names = TRUE, row.names = FALSE, sep="\t") 
> 
> 
> #######################################################
> ########## RECONSTRUCTION OF ANCESTRAL STATE ##########
> #######################################################
> 
> ## load required packages
> require(ape)
Loading required package: ape

Attaching package: ‘ape’

The following objects are masked from ‘package:raster’:

    rotate, zoom

> require(phytools)
Loading required package: phytools
Loading required package: maps
> require(geiger)
Loading required package: geiger

Attaching package: ‘geiger’

The following object is masked from ‘package:raster’:

    hdr

> require(diversitree)
Loading required package: diversitree
> 
> #load climate data
> climate_medians = read.table("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_medians/climate_medians.csv", header=TRUE, sep=",") 
> str(climate_medians)
'data.frame':	112 obs. of  3 variables:
 $ species     : Factor w/ 112 levels "albicaulis","amamiana",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ median_bio4 : num  8086 7405 8409 5290 6825 ...
 $ median_bio17: num  -228.8 116.7 -375 -340.4 -54.7 ...
> 
> #load climate data
> climate_sd = read.table("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_ranges/climate_sd.csv", header=TRUE, sep=",") 
> str(climate_sd)
'data.frame':	112 obs. of  3 variables:
 $ species : Factor w/ 112 levels "albicaulis","amamiana",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ sd_bio4 : num  1360 601 761 1360 1829 ...
 $ sd_bio17: num  151.4 59.4 109.3 61.7 85.4 ...
> climate_se = read.table("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_ranges/climate_se.csv", header=TRUE, sep=",")
> str(climate_se)
'data.frame':	112 obs. of  3 variables:
 $ species : Factor w/ 112 levels "albicaulis","amamiana",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ se_bio4 : num  7.51 34.76 7.07 12.9 11.76 ...
 $ se_bio17: num  0.836 3.437 1.015 0.585 0.549 ...
> 
> ## cargamos el arbol
> tree<-read.nexus("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/datos/phlyo/phylogeny/FBDl_MCC_commAnc.tre") 
> 
> ## new species icnldued by bianca in tree that we have to drop, and also discolor
> species_to_drop = tree$tip.label[which(!tree$tip.label %in% paste("Pinus_", climate_medians$species, sep=""))]
> 
> ## prune the tree of speceis without seed mass data
> tree_prunned = drop.tip(tree, species_to_drop)
> 
> ##reorder rows of climate data in basis on tip labels 
> climate_medians = climate_medians[match(tree_prunned$tip.label, paste("Pinus_", climate_medians$species,sep="")),]
> climate_sd = climate_sd[match(tree_prunned$tip.label, paste("Pinus_", climate_sd$species,sep="")),]
> climate_se = climate_se[match(tree_prunned$tip.label, paste("Pinus_", climate_se$species,sep="")),]
> 
> ## save climatic variables in a vector with species names as names
> bio4_vector = climate_medians$median_bio4
> bio17_vector = climate_medians$median_bio17
> 
> ## set names of these variables as species names
> names(bio4_vector) <- paste("Pinus_", climate_medians$species, sep="")
> names(bio17_vector) <- paste("Pinus_", climate_medians$species, sep="")
> 
> ##intra variability as SE of all data across distribution
> intra_var_bio4 = climate_se$se_bio4
> names(intra_var_bio4) <- paste("Pinus_", climate_se$species, sep="")
> intra_var_bio17 = climate_se$se_bio17
> names(intra_var_bio17) <- paste("Pinus_", climate_se$species, sep="")
> 
> ##check order
> names(bio4_vector) == tree_prunned$tip.label
  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[106] TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> names(bio17_vector) == tree_prunned$tip.label
  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[106] TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> names(intra_var_bio4) == tree_prunned$tip.label
  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[106] TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> names(intra_var_bio17) == tree_prunned$tip.label
  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[106] TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> 
> ############################################
> #### Correlation between bio17 and bio4 ####
> ############################################
> 
> #correlation without PIC
> test_no_pic = cor.test(bio4_vector, bio17_vector, method="spearman")
Warning message:
In cor.test.default(bio4_vector, bio17_vector, method = "spearman") :
  Cannot compute exact p-value with ties
> 
> #correlation with PIC
> pic_bio4 <- pic(bio4_vector, tree_prunned)
> pic.bio17 <- pic(bio17_vector, tree_prunned) 
> test_pic = cor.test(pic.bio17, pic_bio4, method="spearman")
Warning message:
In cor.test.default(pic.bio17, pic_bio4, method = "spearman") :
  Cannot compute exact p-value with ties
> 
> #plot both variables
> pdf("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/climatic_var_medians/cors_bio4_bio17.pdf")
> par(mfrow=c(2,2))
> 
> #NO pic
> plot(bio17_vector~bio4_vector, climate_medians, xlab="Median BIO4", ylab="Median BIO17")
> estimate_no_pic = bquote(italic(rho) == .(format(round(test_no_pic$estimate,2))))
> text(x=14000, y=-320, labels = estimate_no_pic, cex=1)
> p_no_pic = bquote(italic(p.value) == .(format(round(test_no_pic$p.value,4))))
> text(x=14000, y=-400, labels = p_no_pic, cex=1)
> 
> #YES PIC
> plot(pic.bio17~pic_bio4, xlab="PIC Median BIO4", ylab="PIC Median BIO17")
> estimate_pic = bquote(italic(rho) == .(format(round(test_pic$estimate,2))))
> text(x=-1500, y=70, labels = estimate_pic, cex=1)
> p_no_pic = bquote(italic(p.value) == .(format(round(test_pic$p.value,4))))
> text(x=-1500, y=50, labels = p_no_pic, cex=1)
> 
> dev.off()
null device 
          1 
> 
> ####################################
> #### extintio - speciaiton rate ####
> ###################################
> b_d = birthdeath(tree_prunned) #0.242418
> b_d

Estimation of Speciation and Extinction Rates
            with Birth-Death Models

     Phylogenetic tree: tree_prunned 
        Number of tips: 112 
              Deviance: 9.046676 
        Log-likelihood: -4.523338 
   Parameter estimates:
      d / b = 0.242418   StdErr = 0.189111 
      b - d = 0.05098854   StdErr = 0.008523189 
   (b: speciation rate, d: extinction rate)
   Profile likelihood 95% confidence intervals:
      d / b: [-0.02189003, 0.4374309]
      b - d: [0.04152463, 0.06186523]

> 
> ####################################
> #### times nodes (height) ####
> ###################################
> branching.times(tree_prunned)
       113        114        115        116        117        118        119 
124.507576  71.646792  48.339942  30.151894  25.106221  15.728551  11.906791 
       120        121        122        123        124        125        126 
  9.504544   6.283946   9.317364   6.859546   6.601780   5.737440   5.611687 
       127        128        129        130        131        132        133 
  3.587081   5.742998   8.897423   8.326796   5.456404   4.578232  12.282592 
       134        135        136        137        138        139        140 
  3.039246   1.610970   5.844971  47.376781  17.315555  12.278786  44.442538 
       141        142        143        144        145        146        147 
 34.197713  18.408400  12.118111  21.289959  18.572344   9.403151   8.168276 
       148        149        150        151        152        153        154 
  5.808111   2.389132  16.327209   6.432018   1.287831   7.078939  70.856877 
       155        156        157        158        159        160        161 
 48.657804  35.011683  15.069097   9.898791   9.597479   7.894857   6.576156 
       162        163        164        165        166        167        168 
  1.361865   5.893287   8.509618   7.861219   6.004495   2.785382   3.733054 
       169        170        171        172        173        174        175 
  1.379440   9.034795   3.504611   2.708558  22.106205  11.775567   9.021231 
       176        177        178        179        180        181        182 
  2.597257  13.875039  13.000418  11.841472  11.755876  10.004294   9.411960 
       183        184        185        186        187        188        189 
  8.375786  11.487682  10.414925   9.365491   9.922035   7.721418   6.600772 
       190        191        192        193        194        195        196 
  5.222855   6.831567  11.608474   6.005408  10.259971  10.154872   2.658689 
       197        198        199        200        201        202        203 
 25.549466  19.272215   9.441835  50.815026  41.180958  38.046337  16.785935 
       204        205        206        207        208        209        210 
 30.693307  22.305443  16.607423  40.499021  30.233130  26.093453  21.414489 
       211        212        213        214        215        216        217 
 16.292318   9.756746   3.062537   5.231493  12.901611  12.142250   4.836339 
       218        219        220        221        222        223 
  4.712900  17.366523  15.291439   6.910007   7.604835   2.779037 
> 
> ############################
> #### Señal Filogenética ####
> ############################
> 
> ## bio4
> #lambda
> phylosig(tree_prunned, bio4_vector, method="lambda", test=TRUE) #phytools: 0.44
$lambda
[1] 0.4383338

$logL
[1] -1053.922

$logL0
[1] -1057.296

$P
[1] 0.009378378

> fitContinuous(phy = tree_prunned, dat = bio4_vector, model = "lambda", control = list(niter = 100, CI = 0.95), SE=NA) #diversitree without intravariability: 0.44
GEIGER-fitted comparative model of continuous data
 fitted ‘lambda’ model parameters:
	lambda = 0.438405
	sigsq = 99274.964560
	SE = 41.865454
	z0 = 6130.906208

 model summary:
	log-likelihood = -1053.921559
	AIC = 2115.843117
	AICc = 2116.216949
	free parameters = 4

Convergence diagnostics:
	optimization iterations = 100
	failed iterations = 0
	frequency of best fit = 0.13

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates
> fitContinuous(phy = tree_prunned, dat = bio4_vector, model = "lambda", control = list(niter = 100, CI = 0.95), SE=intra_var_bio4) #diversitree with intravariability: 0.44
GEIGER-fitted comparative model of continuous data
 fitted ‘lambda’ model parameters:
	lambda = 0.438321
	sigsq = 99286.003007
	z0 = 6130.931580

 model summary:
	log-likelihood = -1053.922459
	AIC = 2113.844917
	AICc = 2114.067139
	free parameters = 3

Convergence diagnostics:
	optimization iterations = 100
	failed iterations = 0
	frequency of best fit = 0.24

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates
> 
> #k
> phylosig(tree_prunned, bio4_vector, method="K", nsim=200000, test=TRUE) #0.1556661
$K
[1] 0.1556661

$P
[1] 0.000265

> 
> #plot under BM
> obj = contMap(tree_prunned, bio4_vector)
> plot(obj, type="fan")
> 
> ## bio17
> #lambda 
> phylosig(tree_prunned, bio17_vector, method="lambda", test=TRUE) #phytools: 0.94
$lambda
[1] 0.9434205

$logL
[1] -688.3911

$logL0
[1] -719.8396

$P
[1] 2.178169e-15

> fitContinuous(phy = tree_prunned, dat = bio17_vector, model = "lambda", control = list(niter = 100, CI = 0.95), SE=NA) #diversitree without intravariability: 0.94
GEIGER-fitted comparative model of continuous data
 fitted ‘lambda’ model parameters:
	lambda = 0.943441
	sigsq = 494.253906
	SE = 0.000000
	z0 = -261.109652

 model summary:
	log-likelihood = -688.391146
	AIC = 1384.782293
	AICc = 1385.156124
	free parameters = 4

Convergence diagnostics:
	optimization iterations = 100
	failed iterations = 0
	frequency of best fit = 0.11

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates
> fitContinuous(phy = tree_prunned, dat = bio17_vector, model = "lambda", control = list(niter = 100, CI = 0.95), SE=intra_var_bio17) #diversitree with intravariability: 0.94
GEIGER-fitted comparative model of continuous data
 fitted ‘lambda’ model parameters:
	lambda = 0.943426
	sigsq = 494.095214
	z0 = -261.109167

 model summary:
	log-likelihood = -688.393891
	AIC = 1382.787781
	AICc = 1383.010004
	free parameters = 3

Convergence diagnostics:
	optimization iterations = 100
	failed iterations = 0
	frequency of best fit = 0.14

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates
> 
> #k
> phylosig(tree_prunned, bio17_vector, method="K", nsim=10000, test=TRUE) #0.3076953
$K
[1] 0.3076953

$P
[1] 1e-04

> 
> #plot under BM
> obj = contMap(tree_prunned, bio17_vector)
> plot(obj, type="fan")
> 
> #########################################
> ####### Comparison AIC of evo models ####
> #########################################
> 
> ## CREATE a FUNCTION with fitContinuous (GEIGER) to COMPARE MODELS white, BM and OU models considering the existence and estimation of intrapespecific variation (SE = NA) and considenrg no existence of intra variation (SE = 0). 
> fitClim=function(trait=c("median_bio4","median_bio17")){
+ 
+     # select the trait
+     trait=match.arg(trait, c("median_bio4","median_bio17"))
+ 
+     # define set of models to compare
+     models=c("white", "BM", "OU", "lambda")
+     summaries=c("white noise", "Brownian motion", "Ornstein-Uhlenbeck", "lambda")
+     
+     ###### ESTIMATING measurement error ######
+     #Set the intraspecific variance (SE) as NA, with the purpose to be estimate. It is to say, it could exist intraspecific variance, but we don't know it. 
+     
+     #empty vectors to sabe lnl and aic
+     aic.se=numeric(length(models)) 
+     lnl.se=numeric(length(models))
+ 
+     # extract values of the trait and add species names
+     climate_variable = climate_medians[,trait] 
+     names(climate_variable) = paste("Pinus_", climate_medians$species, sep="")
+ 
+     #for each model
+     for(m in 1:length(models)){
+ 
+         #Print the name of the model
+         cat("\n\n\n\n\t*** ", paste(toupper(summaries[m]),": fitting ", sep=""), models[m], " with SE *** \n", sep="")
+         
+         #extract SE of the variable form data within species
+         intra_variation = climate_se[, which(colnames(climate_se) == paste("se_", strsplit(trait, split="_")[[1]][2], sep=""))]
+ 
+         #set names of SE
+         names(intra_variation) <- paste("Pinus_", climate_se$species, sep="")
+ 
+         #fit the model
+         tmp=fitContinuous(phy = tree_prunned, dat = climate_variable, SE=intra_variation, model=models[m], control = list(niter = 1000, CI = 0.95, method = c("subplex","L-BFGS-B")), bounds=list(SE=c(0,0.5)), ncores=2)
+             #SE is for intraspecific variation. 
+             #Beware: difficulty in finding the optimal solution is determined by an interaction between the nature and complexity of the likelihood space (which is data- and model-dependent) and the numerical optimizer used to explore the space. There is never a guarantee that the optimal solution is found, but using many random starting points (control$niter) and many optimization methods (control$method) will increase these odds.
+             #Bounds for the relevant parameters of the fitted model may be given through the bounds argument. Bounds may be necessary (particularly under the OU model) if the likelihood surface is characterized by a long, flat ridge which can be exceedingly difficult for optimization methods. Several bounds can be given at a time (e.g., bounds=list(SE=c(0,0.1),alpha=c(0,1)) would constrain measurement error as well as the ’constraint’ parameter of the Ornstein-Uhlenbeck model). Default bounds under the different models are given below.
+             #Models. We only use white, BM and OU, following Quintero & Wiens 2013. None of these models have assumptions that we violated (in constrast with drif for example -> Not valid for ultrametric trees) 
+                 #BM is the Brownian motion model (Felsenstein 1973), which assumes the correlation structure among trait values is proportional to the extent of shared ancestry for pairs of species. Default bounds on the rate parameter are sigsq=c(min=exp(-500),max=exp(100)). The same bounds are applied to all other models, which also estimate sigsq. 
+                 #OU is the Ornstein-Uhlenbeck model (Butler and King 2004), which fits a random walk with a central tendency with an attraction strength proportional to the parameter alpha. The OU model is called the hansen model in ouch, although the way the parameters are fit is slightly different here. Default bounds are alpha = c(min = exp(-500), max = exp(1)). 
+                 #white is a white-noise (non-phylogenetic) model, which assumes data come from a single normal distribution with no covariance structure among species. The variance parameter sigsq takes the same bounds defined under the BM model
+ 
+         #print results
+         print(tmp)
+ 
+         #save aic and lnL        
+         aic.se[m]=tmp$opt$aicc
+         lnl.se[m]=tmp$opt$lnL
+     }
+ 
+     ###### ASSUMING no measurement error ######
+     #Assuming that there is NO intraespecific variance (SE = 0).
+     
+     #empty vectors to sabe lnl and aic
+     aic=numeric(length(models))
+     lnl=numeric(length(models))
+     
+     #for each model
+     for(m in 1:length(models)){
+ 
+         #Print the name of the model
+         cat("\n\n\n\n\t*** ", paste(toupper(summaries[m]),": fitting ", sep=""), models[m], " *** \n", sep="")
+         
+         #fit the model
+         tmp=fitContinuous(phy = tree_prunned, dat = climate_variable, SE=0, model=models[m], control = list(niter = 1000, CI = 0.95, method = c("subplex","L-BFGS-B")), ncores=2) #SE = 0: NO intraespecific variance
+         
+         #print results
+         print(tmp)
+ 
+         #save aic and lnL
+         aic[m]=tmp$opt$aicc
+         lnl[m]=tmp$opt$lnL
+     }
+ 
+     ###### COMPARE AIC ######
+     #set the names of aic and lnL vectors
+     names(aic.se)<-names(lnl.se)<-names(aic)<-names(lnl)<-models
+ 
+     #create a function to calculate differences of aic
+     delta_aic<-function(x) x-x[which(x==min(x))] #This function calcualate the difference in AIC of all models respect the models with lower AIC (min(x))
+     
+     # delta AIC with no measurement error
+     daic=delta_aic(aic)
+     cat("\n\n\n\t\t\t\t*** MODEL COMPARISON: ",trait," *** \n",sep="")
+     cat("\tdelta-AIC values for models assuming no measurement error \t\t\t\t zero indicates the best model\n\n")
+     print(daic, digits=2)
+     
+     # delta AIC with measurement error
+     daic.se=delta_aic(aic.se)
+     cat("\n\n\n\n\t\t\t\t*** MODEL COMPARISON: ",trait," ***\n",sep="")
+     cat("\t\t delta-AIC values for models estimating SE \t\t\t\t zero indicates the best model\n\n")
+     print(daic.se, digits=2)
+     cat("\n\n\n")
+ 
+     #bind all results 
+     res_aicc=rbind(aic, aic.se, daic, daic.se)
+ 
+     #set names
+     rownames(res_aicc)=c("AICc","AICc_SE","dAICc", "dAICc_SE")
+ 
+     #return those results
+     return(res_aicc)
+ } #function taken from page 19 of "https://cran.r-project.org/web/packages/geiger/geiger.pdf"
> 
> 
> ## bio4 
> res_bio4=fitClim(trait = "median_bio4")




	*** WHITE NOISE: fitting white with SE *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘white’ model parameters:
	sigsq = 9271086.505691
	z0 = 5862.085662

 model summary:
	log-likelihood = -1057.297096
	AIC = 2118.594191
	AICc = 2118.704283
	free parameters = 2

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 1.00

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates




	*** BROWNIAN MOTION: fitting BM with SE *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘BM’ model parameters:
	sigsq = 665572.417616
	z0 = 6050.152917

 model summary:
	log-likelihood = -1063.794684
	AIC = 2131.589367
	AICc = 2131.699459
	free parameters = 2

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 1.00

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates




	*** ORNSTEIN-UHLENBECK: fitting OU with SE *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘OU’ model parameters:
	alpha = 0.077792
	sigsq = 1429156.415598
	z0 = 6162.849773

 model summary:
	log-likelihood = -1047.067317
	AIC = 2100.134633
	AICc = 2100.356855
	free parameters = 3

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 0.23

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates




	*** LAMBDA: fitting lambda with SE *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘lambda’ model parameters:
	lambda = 0.438326
	sigsq = 99286.508948
	z0 = 6130.931875

 model summary:
	log-likelihood = -1053.922459
	AIC = 2113.844917
	AICc = 2114.067139
	free parameters = 3

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 0.24

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates




	*** WHITE NOISE: fitting white *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘white’ model parameters:
	sigsq = 9271100.098316
	z0 = 5862.064939

 model summary:
	log-likelihood = -1057.296215
	AIC = 2118.592430
	AICc = 2118.702522
	free parameters = 2

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 1.00

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates




	*** BROWNIAN MOTION: fitting BM *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘BM’ model parameters:
	sigsq = 665577.238179
	z0 = 6050.130640

 model summary:
	log-likelihood = -1063.792813
	AIC = 2131.585626
	AICc = 2131.695718
	free parameters = 2

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 1.00

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates




	*** ORNSTEIN-UHLENBECK: fitting OU *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘OU’ model parameters:
	alpha = 0.077789
	sigsq = 1429103.977593
	z0 = 6162.824255

 model summary:
	log-likelihood = -1047.065757
	AIC = 2100.131513
	AICc = 2100.353735
	free parameters = 3

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 0.27

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates




	*** LAMBDA: fitting lambda *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘lambda’ model parameters:
	lambda = 0.438341
	sigsq = 99288.854630
	z0 = 6130.906133

 model summary:
	log-likelihood = -1053.921559
	AIC = 2113.843117
	AICc = 2114.065339
	free parameters = 3

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 0.15

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates



				*** MODEL COMPARISON: median_bio4 *** 
	delta-AIC values for models assuming no measurement error 				 zero indicates the best model

 white     BM     OU lambda 
    18     31      0     14 




				*** MODEL COMPARISON: median_bio4 ***
		 delta-AIC values for models estimating SE 				 zero indicates the best model

 white     BM     OU lambda 
    18     31      0     14 



> print(res_bio4) #Best model is OU with a difference of AICc of 15 with the second best model, which is lambda (with and without SE (intraespecific variation)). The last model is BM but close to white noise and lambda (11). 
              white         BM       OU     lambda
AICc     2118.70252 2131.69572 2100.354 2114.06534
AICc_SE  2118.70428 2131.69946 2100.357 2114.06714
dAICc      18.34879   31.34198    0.000   13.71160
dAICc_SE   18.34743   31.34260    0.000   13.71028
>     #alpha = 0.076650
> 
> ## bio17
> res_bio17=fitClim(trait = "median_bio17")




	*** WHITE NOISE: fitting white with SE *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘white’ model parameters:
	sigsq = 22384.074367
	z0 = -240.719613

 model summary:
	log-likelihood = -719.834837
	AIC = 1443.669674
	AICc = 1443.779766
	free parameters = 2

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 1.00

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates




	*** BROWNIAN MOTION: fitting BM with SE *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘BM’ model parameters:
	sigsq = 825.632782
	z0 = -261.627198

 model summary:
	log-likelihood = -689.049596
	AIC = 1382.099191
	AICc = 1382.209283
	free parameters = 2

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 1.00

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates




	*** ORNSTEIN-UHLENBECK: fitting OU with SE *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘OU’ model parameters:
	alpha = 0.027844
	sigsq = 1196.475016
	z0 = -257.941612

 model summary:
	log-likelihood = -682.874284
	AIC = 1371.748568
	AICc = 1371.970790
	free parameters = 3

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 0.23

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates




	*** LAMBDA: fitting lambda with SE *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘lambda’ model parameters:
	lambda = 0.943468
	sigsq = 494.222846
	z0 = -261.109606

 model summary:
	log-likelihood = -688.393891
	AIC = 1382.787781
	AICc = 1383.010003
	free parameters = 3

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 0.00

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates




	*** WHITE NOISE: fitting white *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘white’ model parameters:
	sigsq = 22390.706657
	z0 = -240.704221

 model summary:
	log-likelihood = -719.839587
	AIC = 1443.679174
	AICc = 1443.789265
	free parameters = 2

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 1.00

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates




	*** BROWNIAN MOTION: fitting BM *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘BM’ model parameters:
	sigsq = 825.969434
	z0 = -261.627603

 model summary:
	log-likelihood = -689.049094
	AIC = 1382.098189
	AICc = 1382.208280
	free parameters = 2

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 1.00

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates




	*** ORNSTEIN-UHLENBECK: fitting OU *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘OU’ model parameters:
	alpha = 0.027850
	sigsq = 1196.871013
	z0 = -257.940600

 model summary:
	log-likelihood = -682.870830
	AIC = 1371.741661
	AICc = 1371.963883
	free parameters = 3

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 0.05

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates




	*** LAMBDA: fitting lambda *** 
GEIGER-fitted comparative model of continuous data
 fitted ‘lambda’ model parameters:
	lambda = 0.943427
	sigsq = 494.216317
	z0 = -261.109509

 model summary:
	log-likelihood = -688.391146
	AIC = 1382.782293
	AICc = 1383.004515
	free parameters = 3

Convergence diagnostics:
	optimization iterations = 1000
	failed iterations = 0
	frequency of best fit = 0.00

 object summary:
	'lik' -- likelihood function
	'bnd' -- bounds for likelihood search
	'res' -- optimization iteration summary
	'opt' -- maximum likelihood parameter estimates



				*** MODEL COMPARISON: median_bio17 *** 
	delta-AIC values for models assuming no measurement error 				 zero indicates the best model

 white     BM     OU lambda 
    72     10      0     11 




				*** MODEL COMPARISON: median_bio17 ***
		 delta-AIC values for models estimating SE 				 zero indicates the best model

 white     BM     OU lambda 
    72     10      0     11 



> print(res_bio17) #Best model is OU with a difference of AICc of 10 with the second best model, which is BM (with and without SE (intraespecific variation)). The last model is white noise, very far away (63). Lambda is close to BM (more AICc but only 1 unit). 
              white         BM       OU     lambda
AICc     1443.78927 1382.20828 1371.964 1383.00451
AICc_SE  1443.77977 1382.20928 1371.971 1383.01000
dAICc      71.82538   10.24440    0.000   11.04063
dAICc_SE   71.80898   10.23849    0.000   11.03921
>     #alpha = 0.027591
> #alpha values are equal with and without SE of intraespecific variability.
> 
> 
> ##TABLE 2 with bio4 and bio17 AICc from differents models. 
> 
> #bind results of both variables
> table_2 = rbind.data.frame(res_bio4, res_bio17)
> 
> #drop row names with AICc, dAICc...
> row.names(table_2) <- NULL
> 
> #create a vector with parameters names. This two-step phase is needed becasue binding two dataste created repetead row.names with .1. Two rows cannot have the same name. 
> row_names =c(
+     "AICc",
+     "AICc SE",
+     "\\textdelta AICc",
+     "\\textdelta AICc SE")
> 
> #create a table with names of parameters and results
> table_2 = cbind.data.frame(
+     rep(row_names, 2),
+     table_2)
> 
> #create a column for the variable
> table_2$variable <- NA
> 
> #give it values
> table_2$variable[1] <- "BIO4"
> table_2$variable[5] <- "BIO17"
> 
> #reorder columns and drop lambda values
> table_2 = table_2[,c(6,1,2,3,4)]
> 
> #set final names
> colnames(table_2) <- c("Variables", "Parameter", "White noise", "Brownian Motion", "Ornstein-Uhlenbeck")
> 
> #write to excel
> write.table(table_2, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/tables_figures/table_2.csv", sep=",", row.names=FALSE, col.names=TRUE)
> 
> #convert to a latex table
> require(xtable)
> print.xtable(xtable(table_2, align="lllccc"), include.rownames=FALSE, NA.string="", floating = FALSE, sanitize.text.function=function(x) {x})
% latex table generated in R 3.4.3 by xtable 1.8-2 package
% Mon Aug  6 19:11:20 2018
\begin{tabular}{llccc}
  \hline
Variables & Parameter & White noise & Brownian Motion & Ornstein-Uhlenbeck \\ 
  \hline
BIO4 & AICc & 2118.70 & 2131.70 & 2100.35 \\ 
   & AICc SE & 2118.70 & 2131.70 & 2100.36 \\ 
   & \textdelta AICc & 18.35 & 31.34 & 0.00 \\ 
   & \textdelta AICc SE & 18.35 & 31.34 & 0.00 \\ 
  BIO17 & AICc & 1443.79 & 1382.21 & 1371.96 \\ 
   & AICc SE & 1443.78 & 1382.21 & 1371.97 \\ 
   & \textdelta AICc & 71.83 & 10.24 & 0.00 \\ 
   & \textdelta AICc SE & 71.81 & 10.24 & 0.00 \\ 
   \hline
\end{tabular}
> 
> 
> ################################################
> ############  PHYLOGENETIC MONTECARLO ##########
> ################################################
> 
> #Una de las propuestas de Cooper et al 2016 es hacer bootstrap paramétricos simulando datos bajo los diferentes modelos de evolución a comparar. Vamos a usar un "phylogenetic Montecarlo". 
> 
> #Package for phylogenetic montecarlo
> require(pmc) #Con este paquete vamos a correr un "Phylogenetic Monte Carlo" para la selección entre dos modelos: ModeloA más simple y modeloB más complejo. Primero, los parámetros de ambos modelos son estimados usando los datos originales. Entonces, se simulan n datasets (1000 en nuestro caso como hacen en el paper del paquete) siguiendo la evolución que dicta cada modelo con los parámetros que hemos obtenido previamente. Así obtrendemos un rasgo que evoluciona en nuestra filogenia bajo un modelo BM con el mismo sigma que el de WP, y otro rasgo que evoluciona en nuestra filogenia con el mismo signa, theta y alpha que el de WP. Con cada rasgo se reestiman los paramatroes de los DOS modelos (BM y OU), es decir, el rasgo que evoluciona segun BM se usa para ajustar un BM y un OU, mientras que el rasgo que evoluciona bajo OU se usa para ajustar otro BM y otro OU. Se hace un likelihood ratio test entre ambos modelos para cada rasgo, es decir obtendríamos dos valores de LRT en cada simulación: El valor null, ó hipotesis nula, que sería la diferencia de likelihood entre modelo BM y OU asjutados con un rasgo simulado bajo BM; y el valor test ó nuestro test de interés, que sería la diferencia de likelihood entre modelo BM y OU ambos ajustados con un rasgo que sigue evolución OU. Cuanto mayor sea LRT, más apoyo para el segundo modelo, más complejo, OU en nuestro caso. Esperaríamos, que si el rasgo evouciona por OU y no hay un bias del árbol a favor del modelo más complejo, el LRT del rasgo que evoluciona bajo BM será más bajo que el del rasgo que evoluciona bajo OU, es decir, el modelo OU no es mejor para el caso del rasgo que evoluciona bajo BM. Al final tendremos una distribución de LRT bajo BM y OU que podremos comparar. Ojo al detalle que este procesi implica 4 ajusted por maxima verosimiltud (maximum likelihood), mientras que para un AIC solo usas dos. La figura 2 de "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS" explica muy bien esto. 
Loading required package: pmc

Attaching package: ‘pmc’

The following object is masked _by_ ‘.GlobalEnv’:

    tree

> 
> ############################
> #### Geiger - OU.1 BIO4 ####
> ############################
> #OU con un optimo, en este caso no tenemos estado depedencia
> require(geiger)
> 
> ### extract WP data with species as row.names
> dat = climate_medians[,which(colnames(climate_medians) %in% c("species", "median_bio4"))]
> row.names(dat) <- paste("Pinus_", dat$species, sep="")
> dat[,which(colnames(dat) == "species")] <- NULL
> str(dat)
'data.frame':	112 obs. of  1 variable:
 $ median_bio4: num  8086 7405 8409 5290 6825 ...
> 
> ### bind tree and data into tmp
> tmp = treedata(tree_prunned, dat)
> 
> ### extract phylogeny
> phy = tmp$phy
> 
> ### extract WP data with species as row.names
> datos = tmp$data
> 
> if(FALSE){
+ ### run the phylo montecarlo
+ simulations_ou.1_bio4 = pmc(phy, datos, "BM", "OU", nboot=100, mc.cores=3)
+ 
+ ### save simulations
+ save(simulations_ou.1_bio4, file="/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/rdata/bio_4_geiger_BM_OU.1_nboot_100.rda")
+ }
> 
> ### load it
> load("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/rdata/bio_4_geiger_BM_OU.1_nboot_2000.rda")
> 
> ### plot likelihood ratio test between BM (modelA) and OU.1 (modelB) models fitted with data simulated under BM and OU.1 respectively
> pdf("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/pmc/figures/bio_4_geiger_BM_OU_1_nboot_2000.pdf")
> par(mfrow=c(2,2))
> 
> ## alpha values for data simulated under OU.1
> #comparison BB: BM vs OU.1 model fitted with OU.1-simulated data and the value of alpha (selection strength)
> lr_ou = simulations_ou.1_bio4$test
> 
> #calculate density distribution
> density_lr_OU = density(lr_ou)
> 
> #plot
> plot(density_lr_OU, xlim=c(-0.5,75), ylim=c(0,0.9), xlab="Likelihood ratio test", cex.lab = 1.3, main="")
> 
> #add color to the full area under the curve
> x1 <- min(which(density_lr_OU$x >= 0))  
> x2 <- max(which(density_lr_OU$x <  75))
> with(density_lr_OU, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("black",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_ou = quantile(lr_ou, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_ou[1], quantiles_ou[2]), col="black", lty=2) #No los añado porque podría haber problemas para calcularlos así y no encuentro la función de pmc para ello: "Given the noisy nature of parameters estimated from phylogenies, we recommend that confidence interval should routinely be reported, and to facilitate this, have implemented this as pmc::confidenceIntervals.pow. Confidence intervals could also be estimated from the curvature of the likelihood surface, but these can be unreliable and problematic to compute." From "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS". 
> 
> 
> ## alpha values for data simulated under BM
> #comparison AB: BM vs OU.1 model fitted with BM-simulated data and the value of alpha (selection strength)
> lr_bm = simulations_ou.1_bio4$null
> 
> #calculate density distribution
> density_lr_BM = density(lr_bm)
> 
> #add density plot to the previous plot
> lines(density_lr_BM)
> 
> #add color to the full area under the curve
> x1 <- min(which(density_lr_BM$x >= -0.8))  
> x2 <- max(which(density_lr_BM$x <  13))
> with(density_lr_BM, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("gray",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_BM = quantile(lr_bm, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_BM[1], quantiles_BM[2]), col="black", lty=2)
> 
> #add legen
> #legend(53, 0.85, legend=c("BM", "OU.1"), fill=c("gray", adjustcolor("black",alpha.f=0.65)))
> 
> #add LRT value obtained from real data
> abline(v=c(simulations_ou.1_bio4$lr), col="black", lty=5, lwd=2) #Este valor tiene que estar por encima del percentil 95 del LRT del modeloA (null) y por debajo del percentil 95 del LRT del modeloB (test). Mira la sección Methods-Model selection en "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS".
> #add 95% LR test
> #abline(v=c(quantile(lr_ou, probs=0.95)), col="black", lty=1)
> #abline(v=c(quantile(lr_bm, probs=0.95)), col="black", lty=1) #La proporción de valores simulados mayore que LRT de los datos reales nos da una especie de P.value para el test de selección de modelos. La probabilidad de que la diferencia de likelihood entre modelos (LRT) observada se de bajo el modelo cero. Si cogemos el valor de LRT que es mayor que el 95% de los LRT bajo modeloA, si el LRT observado es mayor que ese threshold, entonces es poco probable que el valor obtenido se haya dado bajo el modeloA (más simple). También podemos calcular el poder del test, la probabilidad de acertar rechazando el modeloA porque los datos vienen del B. Para eso tenemos que usar la distribución de LRTs bajo modelo 1. Si como antes cogemos el valor de LRT mayor que el 95% de LRT simulados bajo modeloB, la cantidad de distribución que queda a la izquierda de ese threshold se aproxima a la probabiidad de rechaza el mdoeloA cuando los datos son producidos por el modeloB. 
> 
> 
> ### plot alpha between data simulated under BM (modelA) and OU.1 (modelB)
> 
> ## alpha values for data simulated under OU.1
> #comparison BB (BM vs OU.1 model fitted with OU.1-simulated data) and the value of alpha (selection strength)
> alpha_ou = simulations_ou.1_bio4$par_dists$value[which(simulations_ou.1_bio4$par_dists$comparison == "BB" & simulations_ou.1_bio4$par_dists$parameter == "alpha")] 
> 
> #calculate density distribution
> density_OU = density(alpha_ou)
> 
> #plot
> plot(density_OU, xlim=c(0,0.39), ylim=c(0,140), , xlab=expression(alpha), cex.lab = 1.3, main="")
> 
> #add color to the full area under the curve
> x1 <- min(which(density_OU$x >= 0))  
> x2 <- max(which(density_OU$x <  0.2))
> with(density_OU, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("black",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_ou = quantile(alpha_ou, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_ou[1], quantiles_ou[2]), col="black", lty=2) #No los añado porque podría haber problemas para calcularlos así y no encuentro la función de pmc para ello: "Given the noisy nature of parameters estimated from phylogenies, we recommend that confidence interval should routinely be reported, and to facilitate this, have implemented this as pmc::confidenceIntervals.pow. Confidence intervals could also be estimated from the curvature of the likelihood surface, but these can be unreliable and problematic to compute." From "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS". 
> 
> ## alpha values for data simulated under BM
> #comparison AB (BM vs OU.1 model fitted with BM-simulated data) and the value of alpha (selection strength)
> alpha_BM = simulations_ou.1_bio4$par_dists$value[which(simulations_ou.1_bio4$par_dists$comparison == "AB" & simulations_ou.1_bio4$par_dists$parameter == "alpha")]
> 
> #calculate density distribution
> density_BM = density(alpha_BM)
> 
> #add density plot to the previous plot
> lines(density_BM)
> 
> #add color to the full area under the curve
> x1 <- min(which(density_BM$x >= -0.2))  
> x2 <- max(which(density_BM$x <  0.2))
> with(density_BM, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("gray",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_BM = quantile(alpha_bm, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_BM[1], quantiles_BM[2]), col="black", lty=2)
> 
> #add legen
> legend(0.27, 133, legend=c("BM", "OU"), fill=c("gray", adjustcolor("black",alpha.f=0.65)))
> 
> #add alpha value obtained from the real data
> abline(v=c(simulations_ou.1_bio4$B$opt$alpha), col="black", lty=5, lwd=2) #Este valor tiene que estar por encima del percentil 95 del LRT del modeloA (null) y por debajo del percentil 95 del LRT del modeloA (test). Mira la sección Methods-Model selection en "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS".
> #add 95% alpha
> #abline(v=c(quantile(alpha_ou, probs=0.95)), col="black", lty=1)
> #abline(v=c(quantile(alpha_BM, probs=0.95)), col="black", lty=1) #Quito estas lineas porque no se si tiene sentido aplicar el approach de poner el 95% de cada parametros en cada modelo, el paper de coop usan este approach con el likelihood ratio test nada más. 
> dev.off()
pdf 
  2 
> 
> 
> #############################
> #### Geiger - OU.1 BIO17 ####
> #############################
> #OU con un optimo, en este caso no tenemos estado depedencia
> require(geiger)
> 
> ### extract WP data with species as row.names
> dat = climate_medians[,which(colnames(climate_medians) %in% c("species", "median_bio17"))]
> row.names(dat) <- paste("Pinus_", dat$species, sep="")
> dat[,which(colnames(dat) == "species")] <- NULL
> str(dat)
'data.frame':	112 obs. of  1 variable:
 $ median_bio17: num  -228.8 116.7 -375 -340.4 -54.7 ...
> 
> ### bind tree and data into tmp
> tmp = treedata(tree_prunned, dat)
> 
> ### extract phylogeny
> phy = tmp$phy
> 
> ### extract WP data with species as row.names
> datos = tmp$data
> 
> if(FALSE){
+ ### run the phylo montecarlo
+ simulations_ou.1_bio17 = pmc(phy, datos, "BM", "OU", nboot=100, mc.cores=3)
+ 
+ ### save simulations
+ save(simulations_ou.1_bio17, file="/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/rdata/bio_17_geiger_BM_OU.1_nboot_100.rda")
+ }
> 
> ### load it
> load("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/rdata/bio_17_geiger_BM_OU.1_nboot_2000.rda")
> 
> 
> ### plot likelihood ratio test between BM (modelA) and OU.1 (modelB) models fitted with data simulated under BM and OU.1 respectively
> pdf("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/pmc/figures/bio_17_geiger_BM_OU_1_nboot_2000.pdf")
> par(mfrow=c(2,2))
> 
> ## alpha values for data simulated under OU.1
> #comparison BB (BM vs OU.1 model fitted with OU.1-simulated data) and the value of alpha (selection strength)
> lr_ou = simulations_ou.1_bio17$test
> 
> #calculate density distribution
> density_lr_OU = density(lr_ou)
> 
> #plot
> plot(density_lr_OU, xlim=c(-0.8,45), ylim=c(0,0.9), xlab="Likelihood ratio test", cex.lab = 1.3, main="")
> 
> #add color to the full area under the curve
> x1 <- min(which(density_lr_OU$x >= -0.8))  
> x2 <- max(which(density_lr_OU$x <  75))
> with(density_lr_OU, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("black",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_ou = quantile(lr_ou, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_ou[1], quantiles_ou[2]), col="black", lty=2) #No los añado porque podría haber problemas para calcularlos así y no encuentro la función de pmc para ello: "Given the noisy nature of parameters estimated from phylogenies, we recommend that confidence interval should routinely be reported, and to facilitate this, have implemented this as pmc::confidenceIntervals.pow. Confidence intervals could also be estimated from the curvature of the likelihood surface, but these can be unreliable and problematic to compute." From "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS". 
> 
> 
> ## alpha values for data simulated under BM
> #comparison AB (BM vs OU.1 model fitted with BM-simulated data) and the value of alpha (selection strength)
> lr_bm = simulations_ou.1_bio17$null
> 
> #calculate density distribution
> density_lr_BM = density(lr_bm)
> 
> #add density plot to the previous plot
> lines(density_lr_BM)
> 
> #add color to the full area under the curve
> x1 <- min(which(density_lr_BM$x >= -0.8))  
> x2 <- max(which(density_lr_BM$x <  13))
> with(density_lr_BM, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("gray",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_BM = quantile(lr_bm, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_BM[1], quantiles_BM[2]), col="black", lty=2)
> 
> #add legen
> #legend(53, 0.85, legend=c("BM", "OU.1"), fill=c("gray", adjustcolor("black",alpha.f=0.65)))
> 
> #value obtained from real data
> abline(v=c(simulations_ou.1_bio17$lr), col="black", lty=5, lwd=2) #Este valor tiene que estar por encima del percentil 95 del LRT del modeloA (null) y por debajo del percentil 95 del LRT del modeloB (test). Mira la sección Methods-Model selection en "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS".
> #add 95% LR test
> #abline(v=c(quantile(lr_ou, probs=0.95)), col="black", lty=1)
> #abline(v=c(quantile(lr_bm, probs=0.95)), col="black", lty=1) #La proporción de valores simulados mayore que LRT de los datos reales nos da una especie de P.value para el test de selección de modelos. La probabilidad de que la diferencia de likelihood entre modelos (LRT) observada se de bajo el modelo cero. Si cogemos el valor de LRT que es mayor que el 95% de los LRT bajo modeloA, si el LRT observado es mayor que ese threshold, entonces es poco probable que el valor obtenido se haya dado bajo el modeloA (más simple). También podemos calcular el poder del test, la probabilidad de acertar rechazando el modeloA porque los datos vienen del B. Para eso tenemos que usar la distribución de LRTs bajo modelo 1. Si como antes cogemos el valor de LRT mayor que el 95% de LRT simulados bajo modeloB, la cantidad de distribución que queda a la izquierda de ese threshold se aproxima a la probabiidad de rechaza el mdoeloA cuando los datos son producidos por el modeloB. 
> 
> 
> ### plot alpha between data simulated under BM (modelA) and OU.1 (modelB)
> 
> ## alpha values for data simulated under OU.1
> #comparison BB (OU.1 model fitted with OU.1-simulated data) and the value of alpha (selection strength)
> alpha_ou = simulations_ou.1_bio17$par_dists$value[which(simulations_ou.1_bio17$par_dists$comparison == "BB" & simulations_ou.1_bio17$par_dists$parameter == "alpha")] 
> 
> #calculate density distribution
> density_OU = density(alpha_ou)
> 
> #plot
> plot(density_OU, xlim=c(0,0.12), ylim=c(0,137), , xlab=expression(alpha), cex.lab = 1.3,, main="")
> 
> #add color to the full area under the curve
> x1 <- min(which(density_OU$x >= 0))  
> x2 <- max(which(density_OU$x <  0.2))
> with(density_OU, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("black",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_ou = quantile(alpha_ou, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_ou[1], quantiles_ou[2]), col="black", lty=2) #No los añado porque podría haber problemas para calcularlos así y no encuentro la función de pmc para ello: "Given the noisy nature of parameters estimated from phylogenies, we recommend that confidence interval should routinely be reported, and to facilitate this, have implemented this as pmc::confidenceIntervals.pow. Confidence intervals could also be estimated from the curvature of the likelihood surface, but these can be unreliable and problematic to compute." From "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS". 
> 
> ## alpha values for data simulated under BM
> #comparison AB (BM vs OU.1 model fitted with BM-simulated data) and the value of alpha (selection strength)
> alpha_BM = simulations_ou.1_bio17$par_dists$value[which(simulations_ou.1_bio17$par_dists$comparison == "AB" & simulations_ou.1_bio17$par_dists$parameter == "alpha")]
> 
> #calculate density distribution
> density_BM = density(alpha_BM)
> 
> #add density plot to the previous plot
> lines(density_BM)
> 
> #add color to the full area under the curve
> x1 <- min(which(density_BM$x >= -0.2))  
> x2 <- max(which(density_BM$x <  0.2))
> with(density_BM, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("gray",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_BM = quantile(alpha_bm, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_BM[1], quantiles_BM[2]), col="black", lty=2)
> 
> #add legen
> legend(0.085, 130, legend=c("BM", "OU"), fill=c("gray", adjustcolor("black",alpha.f=0.65)))
> 
> #add alpha vlaue form real data
> abline(v=c(simulations_ou.1_bio17$B$opt$alpha), col="black", lty=5, lwd=2) #Este valor tiene que estar por encima del percentil 95 del LRT del modeloA (null) y por debajo del percentil 95 del LRT del modeloA (test). Mira la sección Methods-Model selection en "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS".
> #add 95% alpha
> #abline(v=c(quantile(alpha_ou, probs=0.95)), col="black", lty=1)
> #abline(v=c(quantile(alpha_BM, probs=0.95)), col="black", lty=1) #Quito estas lineas porque no se si tiene sentido aplicar el approach de poner el 95% de cada parametros en cada modelo, el paper de coop usan este approach con el likelihood ratio test nada más. 
> dev.off()
pdf 
  2 
> 
> ####### FINAL Figure for the paper ########
> ### plot likelihood ratio test between BM (modelA) and OU.1 (modelB) models fitted with data simulated under BM and OU.1 respectively
> pdf("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/pmc/figures/bio_4_17_geiger_BM_OU_1_nboot_2000.pdf")
> par(mfrow=c(2,2))
> 
> #######BIO4
> ### load it
> load("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/rdata/bio_4_geiger_BM_OU.1_nboot_2000.rda")
> 
> ## alpha values for data simulated under OU.1
> #comparison BB (OU.1 model fitted with OU.1-simulated data) and the value of alpha (selection strength)
> lr_ou = simulations_ou.1_bio4$test
> 
> #calculate density distribution
> density_lr_OU = density(lr_ou)
> 
> #plot
> plot(density_lr_OU, xlim=c(-0.5,75), ylim=c(0,0.9), xlab="Likelihood ratio test", cex.lab = 1.3, main="")
> 
> #add title
> mtext(text=expression(bold("Temperature Seasonality  (BIO4)")), side=3, at=95, line=1.4)
> 
> #add color to the full area under the curve
> x1 <- min(which(density_lr_OU$x >= 0))  
> x2 <- max(which(density_lr_OU$x <  75))
> with(density_lr_OU, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("black",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_ou = quantile(lr_ou, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_ou[1], quantiles_ou[2]), col="black", lty=2) #No los añado porque podría haber problemas para calcularlos así y no encuentro la función de pmc para ello: "Given the noisy nature of parameters estimated from phylogenies, we recommend that confidence interval should routinely be reported, and to facilitate this, have implemented this as pmc::confidenceIntervals.pow. Confidence intervals could also be estimated from the curvature of the likelihood surface, but these can be unreliable and problematic to compute." From "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS". 
> 
> 
> ## alpha values for data simulated under BM
> #comparison AB (OU.1 model fitted with BM-simulated data) and the value of alpha (selection strength)
> lr_bm = simulations_ou.1_bio4$null
> 
> #calculate density distribution
> density_lr_BM = density(lr_bm)
> 
> #add density plot to the previous plot
> lines(density_lr_BM)
> 
> #add color to the full area under the curve
> x1 <- min(which(density_lr_BM$x >= -0.8))  
> x2 <- max(which(density_lr_BM$x <  13))
> with(density_lr_BM, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("gray",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_BM = quantile(lr_bm, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_BM[1], quantiles_BM[2]), col="black", lty=2)
> 
> #add legen
> #legend(53, 0.85, legend=c("BM", "OU.1"), fill=c("gray", adjustcolor("black",alpha.f=0.65)))
> 
> #add 95% LR test
> abline(v=c(simulations_ou.1_bio4$lr), col="black", lty=5, lwd=2) #Este valor tiene que estar por encima del percentil 95 del LRT del modeloA (null) y por debajo del percentil 95 del LRT del modeloB (test). Mira la sección Methods-Model selection en "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS".
> #abline(v=c(quantile(lr_ou, probs=0.95)), col="black", lty=1)
> #abline(v=c(quantile(lr_bm, probs=0.95)), col="black", lty=1) #La proporción de valores simulados mayore que LRT de los datos reales nos da una especie de P.value para el test de selección de modelos. La probabilidad de que la diferencia de likelihood entre modelos (LRT) observada se de bajo el modelo cero. Si cogemos el valor de LRT que es mayor que el 95% de los LRT bajo modeloA, si el LRT observado es mayor que ese threshold, entonces es poco probable que el valor obtenido se haya dado bajo el modeloA (más simple). También podemos calcular el poder del test, la probabilidad de acertar rechazando el modeloA porque los datos vienen del B. Para eso tenemos que usar la distribución de LRTs bajo modelo 1. Si como antes cogemos el valor de LRT mayor que el 95% de LRT simulados bajo modeloB, la cantidad de distribución que queda a la izquierda de ese threshold se aproxima a la probabiidad de rechaza el mdoeloA cuando los datos son producidos por el modeloB. 
> 
> 
> ### plot alpha between data simulated under BM (modelA) and OU.1 (modelB)
> 
> ## alpha values for data simulated under OU.1
> #comparison BB (OU.1 model fitted with OU.1-simulated data) and the value of alpha (selection strength)
> alpha_ou = simulations_ou.1_bio4$par_dists$value[which(simulations_ou.1_bio4$par_dists$comparison == "BB" & simulations_ou.1_bio4$par_dists$parameter == "alpha")] 
> 
> #calculate density distribution
> density_OU = density(alpha_ou)
> 
> #plot
> plot(density_OU, xlim=c(0,0.39), ylim=c(0,140), , xlab=expression(alpha), cex.lab = 1.3, main="")
> 
> #add color to the full area under the curve
> x1 <- min(which(density_OU$x >= 0))  
> x2 <- max(which(density_OU$x <  0.2))
> with(density_OU, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("black",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_ou = quantile(alpha_ou, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_ou[1], quantiles_ou[2]), col="black", lty=2) #No los añado porque podría haber problemas para calcularlos así y no encuentro la función de pmc para ello: "Given the noisy nature of parameters estimated from phylogenies, we recommend that confidence interval should routinely be reported, and to facilitate this, have implemented this as pmc::confidenceIntervals.pow. Confidence intervals could also be estimated from the curvature of the likelihood surface, but these can be unreliable and problematic to compute." From "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS". 
> 
> ## alpha values for data simulated under BM
> #comparison AB (OU.1 model fitted with BM-simulated data) and the value of alpha (selection strength)
> alpha_BM = simulations_ou.1_bio4$par_dists$value[which(simulations_ou.1_bio4$par_dists$comparison == "AB" & simulations_ou.1_bio4$par_dists$parameter == "alpha")]
> 
> #calculate density distribution
> density_BM = density(alpha_BM)
> 
> #add density plot to the previous plot
> lines(density_BM)
> 
> #add color to the full area under the curve
> x1 <- min(which(density_BM$x >= -0.2))  
> x2 <- max(which(density_BM$x <  0.2))
> with(density_BM, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("gray",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_BM = quantile(alpha_bm, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_BM[1], quantiles_BM[2]), col="black", lty=2)
> 
> #add legen
> legend(0.27, 133, legend=c("BM", "OU"), fill=c("gray", adjustcolor("black",alpha.f=0.65)))
> 
> #add 95% LR test
> abline(v=c(simulations_ou.1_bio4$B$opt$alpha), col="black", lty=5, lwd=2) #Este valor tiene que estar por encima del percentil 95 del LRT del modeloA (null) y por debajo del percentil 95 del LRT del modeloA (test). Mira la sección Methods-Model selection en "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS".
> #abline(v=c(quantile(alpha_ou, probs=0.95)), col="black", lty=1)
> #abline(v=c(quantile(alpha_BM, probs=0.95)), col="black", lty=1) #Quito estas lineas porque no se si tiene sentido aplicar el approach de poner el 95% de cada parametros en cada modelo, el paper de coop usan este approach con el likelihood ratio test nada más. 
> 
> 
> ####BIO17 
> 
> ### load it
> load("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/rdata/bio_17_geiger_BM_OU.1_nboot_2000.rda")
> 
> 
> ## alpha values for data simulated under OU.1
> #comparison BB (OU.1 model fitted with OU.1-simulated data) and the value of alpha (selection strength)
> lr_ou = simulations_ou.1_bio17$test
> 
> #calculate density distribution
> density_lr_OU = density(lr_ou)
> 
> #plot
> plot(density_lr_OU, xlim=c(-0.8,45), ylim=c(0,0.9), xlab="Likelihood ratio test", cex.lab = 1.3, main="")
> 
> #add title
> mtext(text=expression(bold("Moisture of Driest Quarter  (BIO17)")), side=3, at=57, line=1.4)
> 
> #add color to the full area under the curve
> x1 <- min(which(density_lr_OU$x >= -0.8))  
> x2 <- max(which(density_lr_OU$x <  75))
> with(density_lr_OU, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("black",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_ou = quantile(lr_ou, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_ou[1], quantiles_ou[2]), col="black", lty=2) #No los añado porque podría haber problemas para calcularlos así y no encuentro la función de pmc para ello: "Given the noisy nature of parameters estimated from phylogenies, we recommend that confidence interval should routinely be reported, and to facilitate this, have implemented this as pmc::confidenceIntervals.pow. Confidence intervals could also be estimated from the curvature of the likelihood surface, but these can be unreliable and problematic to compute." From "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS". 
> 
> 
> ## alpha values for data simulated under BM
> #comparison AB (OU.1 model fitted with BM-simulated data) and the value of alpha (selection strength)
> lr_bm = simulations_ou.1_bio17$null
> 
> #calculate density distribution
> density_lr_BM = density(lr_bm)
> 
> #add density plot to the previous plot
> lines(density_lr_BM)
> 
> #add color to the full area under the curve
> x1 <- min(which(density_lr_BM$x >= -0.8))  
> x2 <- max(which(density_lr_BM$x <  13))
> with(density_lr_BM, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("gray",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_BM = quantile(lr_bm, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_BM[1], quantiles_BM[2]), col="black", lty=2)
> 
> #add legen
> #legend(53, 0.85, legend=c("BM", "OU.1"), fill=c("gray", adjustcolor("black",alpha.f=0.65)))
> 
> #add 95% LR test
> abline(v=c(simulations_ou.1_bio17$lr), col="black", lty=5, lwd=2) #Este valor tiene que estar por encima del percentil 95 del LRT del modeloA (null) y por debajo del percentil 95 del LRT del modeloB (test). Mira la sección Methods-Model selection en "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS".
> #abline(v=c(quantile(lr_ou, probs=0.95)), col="black", lty=1)
> #abline(v=c(quantile(lr_bm, probs=0.95)), col="black", lty=1) #La proporción de valores simulados mayore que LRT de los datos reales nos da una especie de P.value para el test de selección de modelos. La probabilidad de que la diferencia de likelihood entre modelos (LRT) observada se de bajo el modelo cero. Si cogemos el valor de LRT que es mayor que el 95% de los LRT bajo modeloA, si el LRT observado es mayor que ese threshold, entonces es poco probable que el valor obtenido se haya dado bajo el modeloA (más simple). También podemos calcular el poder del test, la probabilidad de acertar rechazando el modeloA porque los datos vienen del B. Para eso tenemos que usar la distribución de LRTs bajo modelo 1. Si como antes cogemos el valor de LRT mayor que el 95% de LRT simulados bajo modeloB, la cantidad de distribución que queda a la izquierda de ese threshold se aproxima a la probabiidad de rechaza el mdoeloA cuando los datos son producidos por el modeloB. 
> 
> 
> ### plot alpha between data simulated under BM (modelA) and OU.1 (modelB)
> 
> ## alpha values for data simulated under OU.1
> #comparison BB (OU.1 model fitted with OU.1-simulated data) and the value of alpha (selection strength)
> alpha_ou = simulations_ou.1_bio17$par_dists$value[which(simulations_ou.1_bio17$par_dists$comparison == "BB" & simulations_ou.1_bio17$par_dists$parameter == "alpha")] 
> 
> #calculate density distribution
> density_OU = density(alpha_ou)
> 
> #plot
> plot(density_OU, xlim=c(0,0.12), ylim=c(0,137), , xlab=expression(alpha), cex.lab = 1.3,, main="")
> 
> #add color to the full area under the curve
> x1 <- min(which(density_OU$x >= 0))  
> x2 <- max(which(density_OU$x <  0.2))
> with(density_OU, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("black",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_ou = quantile(alpha_ou, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_ou[1], quantiles_ou[2]), col="black", lty=2) #No los añado porque podría haber problemas para calcularlos así y no encuentro la función de pmc para ello: "Given the noisy nature of parameters estimated from phylogenies, we recommend that confidence interval should routinely be reported, and to facilitate this, have implemented this as pmc::confidenceIntervals.pow. Confidence intervals could also be estimated from the curvature of the likelihood surface, but these can be unreliable and problematic to compute." From "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS". 
> 
> ## alpha values for data simulated under BM
> #comparison AB (OU.1 model fitted with BM-simulated data) and the value of alpha (selection strength)
> alpha_BM = simulations_ou.1_bio17$par_dists$value[which(simulations_ou.1_bio17$par_dists$comparison == "AB" & simulations_ou.1_bio17$par_dists$parameter == "alpha")]
> 
> #calculate density distribution
> density_BM = density(alpha_BM)
> 
> #add density plot to the previous plot
> lines(density_BM)
> 
> #add color to the full area under the curve
> x1 <- min(which(density_BM$x >= -0.2))  
> x2 <- max(which(density_BM$x <  0.2))
> with(density_BM, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col=adjustcolor("gray",alpha.f=0.65)))
> 
> #plot 95CI
> #quantiles_BM = quantile(alpha_bm, prob=c(0.025, 0.975))
> #abline(v=c(quantiles_BM[1], quantiles_BM[2]), col="black", lty=2)
> 
> #add legen
> #legend(0.085, 130, legend=c("BM", "OU"), fill=c("gray", adjustcolor("black",alpha.f=0.65)))
> 
> #add 95% LR test
> abline(v=c(simulations_ou.1_bio17$B$opt$alpha), col="black", lty=5, lwd=2) #Este valor tiene que estar por encima del percentil 95 del LRT del modeloA (null) y por debajo del percentil 95 del LRT del modeloA (test). Mira la sección Methods-Model selection en "IS YOUR PHYLOGENY INFORMATIVE? MEASURING THE POWER OF COMPARATIVE METHODS".
> #abline(v=c(quantile(alpha_ou, probs=0.95)), col="black", lty=1)
> #abline(v=c(quantile(alpha_BM, probs=0.95)), col="black", lty=1) #Quito estas lineas porque no se si tiene sentido aplicar el approach de poner el 95% de cada parametros en cada modelo, el paper de coop usan este approach con el likelihood ratio test nada más. 
> dev.off()
pdf 
  2 
> 
> 
> 
> ################################
> #### phylogenetic half-life ####
> ################################
> 
> #max height of the tree
> height_tree = max(nodeHeights(tree_prunned)[,2])
> 
> #t[1/2] for BIO4 and BIO17
> t_1_2_bio4 = log(2)/0.08
> t_1_2_bio17 = log(2)/0.03
> 
> #difference between t[1/2] and max height
> t_1_2_bio4/height_tree
[1] 0.06958886
> t_1_2_bio17/height_tree #El timepo que tarda una especie que entra en nu nuevo nicho en llegar a la mitad de camino hacia su nuevo óptimo esperado. Si ese valor es muy pequeo en relación con la altura del árbol, entonces la evolución hacia el rago optimo es rápida y las correlaciones filogeneitcas residuales son debiles y hay poca influencia de los valores antiguos del rasgo. A nosotros nos sale un valor muy bajo respecto de la altura del árbol, pero hay que tener en cuenta que la estrcutura del arbul afecta al valor de alfa, ciertas formas de árbol pueden dar lugar a valores más altos de alfa independientemente del rasgo que estés mirando, y t_1_2 se calcula con alfa, así que tenemos esos sesgos. Cooper et al 2016 vieron que con alfa menor de 1, BM y OU son prácticamente indiferenciables. 
[1] 0.1855703
> 
> 
> #####################################
> ####### Extract ancestal state ######
> #####################################
> 
> ####### OU and BM in Comare 4.6 #########
> #extract species names
> species_names = paste("Pinus_", climate_medians$species, sep="")
> 
> #write species names
> write.table(species_names, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/compare4.6_data/compare_species_names.txt", sep="\t", col.names = FALSE, row.names =  FALSE, quote=FALSE) #We don't want quotes because these files will be copied to compare. quote: a logical value (‘TRUE’ or ‘FALSE’) or a numeric vector.  If ‘TRUE’, any character or factor columns will be surrounded by double quotes.  If a numeric vector, its elements are taken as the indices of columns to quote.  In both cases, row and column names are quoted if they are written.  If ‘FALSE’, nothing is quoted.
> 
> #bind climatic data to SE estimates (0 in our cases for all speices because we have not intraspecies data)
> climate_medians$species == climate_se$species
  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
 [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[106] TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> compare_bio4 = paste(climate_medians$median_bio4, "<", climate_se$se_bio4, ">", sep="")
> compare_bio17 = paste(climate_medians$median_bio17, "<", climate_se$se_bio17, ">", sep="")
> 
> #write variables
> write.table(compare_bio4, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/compare4.6_data/compare_bio4.txt", sep="\t", col.names = FALSE, row.names =  FALSE, quote=FALSE) #YOU HAVE TO DROP " FROM THE FILE
> write.table(compare_bio17, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/compare4.6_data/compare_bio17.txt", sep="\t", col.names = FALSE, row.names =  FALSE, quote=FALSE) #YOU HAVE TO DROP " FROM THE FILE
> 
> #save the tree prunned for compare 4.6
> write.tree(tree_prunned, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/compare4.6_data/FBDl_MCC_commAnc_prunned.tree") #You have to copy hasta el ";", no etas espacio, sino no funciona
> 
> 
> #En "/Volumes/GoogleDrive/My Drive/science/software/Comp46bExec" pinchas startForm.class para activar compare. Le das a main window. 
> 
> #Copias todos estos archivos creados con al código de justo arriba en Taxon names, Taxon means (rasgos) y Enter Phylogeny. Indicas que son 112 taxa, 1 rasgo y 1 filogenia. Hay que indicar que si queremos usar los SE dentro de especie ó asumir que la variación dentro de especie es desconocida. En este caso incluímos los valores de SE como variabilidad intraespecífica. Seleccionar PGLS-ancestros y exeecute.   
> 
> #Correr modelo: 
>     #BM: Linear model which is the option by default. Not select specyfing alpha. Nothing else. 
>     #OU:Luego Exponential model, specyfing Alpha, pon el valor de alfa de bio4  ó bio17 redondeados a dos decimales (0.08 y 0.03 respectivamente), 100 iteraciones y run (he comprobado el resultado con 1000 interaciones en ambas variablws y sale exactamente lo mismo). Asú se corre un OU en comapre4.6. Esto se ha seguido de Guerrero et al.,... Wiens ., 2013 ("https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3710863/")
> 
> #Le das a guardar en un archivo llamado "compare_res_bioX_XX.txt". De ese archivo copias la parte de "Trait #1: Ancestral state estimates" y la pegas en un excel, le das a pegar con el importador de datos (se hace en el boton que surge al pegar como el de mantener-quitar formato). Así te separará cada columna. Solo falta añadir a "Adj." el "SE" que queda en la siguiente columna (es SE adjusted) y guardar como .csv.
> 
> #load results of OU with SE intraespecífica (alpha = 0.07 for bio4 and 0.03 for bio17)
> anc_ou_bio4 = read.table("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/compare_results/anc_bio4_ou.csv", sep=",", header=TRUE)
> str(anc_ou_bio4)
'data.frame':	111 obs. of  4 variables:
 $ Node  : Factor w/ 111 levels "114","115","116",..: 111 1 2 3 4 5 6 7 8 9 ...
 $ State : num  6193 6201 6244 6416 6520 ...
 $ SE    : num  1775 5099 5088 4953 4801 ...
 $ Adj.SE: num  1775 535 535 552 574 ...
> anc_ou_bio17 = read.table("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/compare_results/anc_bio17_ou.csv", sep=",", header=TRUE)
> str(anc_ou_bio17)
'data.frame':	111 obs. of  4 variables:
 $ Node  : Factor w/ 111 levels "114","115","116",..: 111 1 2 3 4 5 6 7 8 9 ...
 $ State : num  -244 -259 -208 -178 -167 ...
 $ SE    : num  46.4 167.4 152.4 128.2 115.5 ...
 $ Adj.SE: num  46.4 27.3 34.9 43.3 47.6 ...
> 
> #change names of root by 112+1 (ass notation of ape)
> #bio4
> first_node = length(tree_prunned$tip.label) + 1
> levels(anc_ou_bio4$Node) = c(levels(anc_ou_bio4$Node), eval(first_node))
> anc_ou_bio4$Node[which(anc_ou_bio4$Node == "Root")] <-  length(tree_prunned$tip.label) + 1
> anc_ou_bio4$Node = droplevels(anc_ou_bio4$Node)
> #bio17
> first_node = length(tree_prunned$tip.label) + 1
> levels(anc_ou_bio17$Node) = c(levels(anc_ou_bio17$Node), eval(first_node))
> anc_ou_bio17$Node[which(anc_ou_bio17$Node == "Root")] <-  length(tree_prunned$tip.label) + 1
> anc_ou_bio17$Node = droplevels(anc_ou_bio17$Node)
> 
> #change the name of Node to nodo1 for mergin with data.frame of node-species numbers
> colnames(anc_ou_bio4)[which(colnames(anc_ou_bio4) == "Node")] <- "nodo1" 
> colnames(anc_ou_bio17)[which(colnames(anc_ou_bio17) == "Node")] <- "nodo1" 
> 
> ##### BM y OU con ace (ape) #######
> ## bio4
> # BM
> ml_recon_bio4 = ace(x=bio4_vector, phy=tree_prunned, type="continuous", method = "ML", CI = TRUE, model="BM", marginal=FALSE) 
>     #If type = "continuous", the default model is Brownian motion where characters evolve randomly following a random walk. This model can be fitted by residual maximum likelihood (the default), maximum likelihood (Felsenstein 1973, Schluter et al. 1997), least squares (method = "pic", Felsenstein 1985), or generalized least squares (method = "GLS", Martins and Hansen 1997, Cunningham et al. 1998). In the last case, the specification of phy and model are actually ignored: it is instead given through a correlation structure with the option corStruct. 
>     #In the setting method = "ML" and model = "BM" (this used to be the default until ape 3.0-7) the maximum likelihood estimation is done simultaneously on the ancestral values and the variance of the Brownian motion process; these estimates are then used to compute the confidence intervals in the standard way. The REML method first estimates the ancestral value at the root (aka, the phylogenetic mean), then the variance of the Brownian motion process is estimated by optimizing the residual log-likelihood. The ancestral values are finally inferred from the likelihood function giving these two parameters. If method = "pic" or "GLS", the confidence intervals are computed using the expected variances under the model, so they depend only on the tree. 
>     #It could be shown that, with a continous character, REML results in unbiased estimates of the variance of the Brownian motion process while ML gives a downward bias. Therefore the former is recommanded.
>     #By default, the likelihood of the different ancestral states of discrete characters are computed with a joint estimation procedure using a procedure similar to the one described in Pupko et al. (2000). If marginal = TRUE, a marginal estimation procedure is used (this was the only choice until ape 3.1- 1). With this method, the likelihood values at a given node are computed using only the information from the tips (and branches) descending from this node. With the joint estimation, all information is used for each node. The difference between these two methods is further explained in Felsenstein (2004, pp. 259-260) and in Yang (2006, pp. 121-126). The present implementation of the joint estimation uses a “two-pass” algorithm which is much faster than stochastic mapping while the estimates of both methods are very close.
> reml_recon_bio4 = ace(x=bio4_vector, phy=tree_prunned, type="continuous", method = "REML", CI = TRUE, model="BM", marginal=FALSE)
> pgls_recon_bio4 = ace(x=bio4_vector, phy=tree_prunned, type="continuous", method = "GLS", CI = TRUE, model="BM", marginal=FALSE, corStruct = corBrownian(1, phy = tree_prunned))
>     #ML no estima el 95CI y además el manual de ape dice que ML puede dar estimar con bias en rasgos continuos. Ademá
> 
> # BM with reconstruct (APE)
> ml_recontruct_bio4 = reconstruct(bio4_vector, tree_prunned, method = "ML", alpha = NULL, CI = TRUE)
> reml_recontruct_bio4 = reconstruct(bio4_vector, tree_prunned, method = "REML", alpha = NULL, CI = TRUE)
> pgl_recontruct_bio4 = reconstruct(bio4_vector, tree_prunned, method = "GLS", alpha = NULL, CI = TRUE)
> 
> #compare ancestral states of BM all models
> ml_recon_bio4$ace - reml_recon_bio4$ace
         113          114          115          116          117          118 
 -188.069139    74.000656     8.043741  -778.291000  -894.518129 -1771.939075 
         119          120          121          122          123          124 
-2135.639985 -1988.973087 -2236.796461 -2540.154669  -402.294926  -348.239961 
         125          126          127          128          129          130 
 -143.984284  -159.013463  -739.008242  -371.277548 -2971.039147 -3709.798619 
         131          132          133          134          135          136 
-5950.542777 -5737.681888     9.864720   850.019003  -592.648461  -121.343513 
         137          138          139          140          141          142 
   46.948319 -1467.951905 -2217.039562   285.737044    44.972506 -1250.142468 
         143          144          145          146          147          148 
-1912.975978  1009.901948   823.796188   -97.195132    88.936797   345.782359 
         149          150          151          152          153          154 
  978.021233   895.533508  -685.957798  -218.282823  2427.460304  -453.876806 
         155          156          157          158          159          160 
 -880.954503   128.587676   805.152331  1554.753069  1512.374206  1032.833923 
         161          162          163          164          165          166 
  587.254047  1170.552422  1145.416859  1665.749425  1594.746484  2293.111177 
         167          168          169          170          171          172 
 2374.433788  3315.729933  3654.964477   135.008733    76.082911  -140.385706 
         173          174          175          176          177          178 
  645.535705    78.996941  -250.409190   673.306052  1426.639923  1380.793497 
         179          180          181          182          183          184 
 1834.151519  1890.881722  2488.404468  2593.279002  2799.345308  1977.155444 
         185          186          187          188          189          190 
 2302.373802  2458.594310  2006.095687  1655.334639  1836.402999  1586.759166 
         191          192          193          194          195          196 
 2555.746996   763.299622  1686.778767   -57.187339  -106.416926 -2450.014401 
         197          198          199          200          201          202 
-3035.042440 -2544.597595 -1822.016156  -167.551243  -326.906727  -308.898711 
         203          204          205          206          207          208 
 -888.396703   -66.251702   243.863867   651.356339   150.457933  -355.450764 
         209          210          211          212          213          214 
 -347.048819 -1058.431637  -612.836978  -384.553527   547.641490  -856.648589 
         215          216          217          218          219          220 
 -436.313845  -372.446981  1543.483821  -698.548249 -2026.048876 -2347.311554 
         221          222          223 
-4217.653879 -2848.129595  3171.828215 
> ml_recon_bio4$ace - pgls_recon_bio4$ace
         113          114          115          116          117          118 
 -188.065702    73.842323     7.898159  -778.388921  -894.611102 -1771.999254 
         119          120          121          122          123          124 
-2135.714056 -1989.031022 -2236.834885 -2540.248893  -402.385217  -348.329642 
         125          126          127          128          129          130 
 -144.073856  -159.101517  -739.052493  -371.349231 -2971.131466 -3709.883882 
         131          132          133          134          135          136 
-5950.598493 -5737.728870     9.827030   850.009281  -592.654852  -121.357573 
         137          138          139          140          141          142 
   46.804393 -1468.014158 -2217.088839   285.602010    44.878910 -1250.181776 
         143          144          145          146          147          148 
-1912.986873  1009.829757   823.734222   -97.229413    88.906646   345.763362 
         149          150          151          152          153          154 
  978.014051   895.482435  -685.970740  -218.287123  2427.433601  -453.887497 
         155          156          157          158          159          160 
 -880.972864   128.557534   805.112784  1554.706376  1512.328698  1032.804891 
         161          162          163          164          165          166 
  587.232005  1170.547660  1145.399756  1665.710962  1594.710450  2293.096093 
         167          168          169          170          171          172 
 2374.431280  3315.712370  3654.958445   134.978031    76.063628  -140.401884 
         173          174          175          176          177          178 
  645.475428    78.961162  -250.437417   673.297998  1426.531012  1380.674845 
         179          180          181          182          183          184 
 1834.031732  1890.763138  2488.322741  2593.207095  2799.286726  1977.043572 
         185          186          187          188          189          190 
 2302.277944  2458.511609  2006.017278  1655.286031  1836.365909  1586.732493 
         191          192          193          194          195          196 
 2555.702694   763.174126  1686.730658   -57.331920  -106.561305 -2450.037436 
         197          198          199          200          201          202 
-3035.067351 -2544.626167 -1822.026101  -167.605536  -326.970650  -308.958509 
         203          204          205          206          207          208 
 -888.418926   -66.287254   243.847812   651.348740   150.398541  -355.501631 
         209          210          211          212          213          214 
 -347.100910 -1058.491765  -612.885160  -384.577813   547.633884  -856.660060 
         215          216          217          218          219          220 
 -436.356086  -372.487355  1543.473737  -698.568316 -2026.110353 -2347.368865 
         221          222          223 
-4217.678313 -2848.154155  3171.828714 
> reml_recon_bio4$ace - pgls_recon_bio4$ace
          113           114           115           116           117 
 0.0034371260 -0.1583327765 -0.1455818879 -0.0979206335 -0.0929732428 
          118           119           120           121           122 
-0.0601789766 -0.0740703679 -0.0579343872 -0.0384242469 -0.0942240045 
          123           124           125           126           127 
-0.0902908429 -0.0896803839 -0.0895722984 -0.0880541893 -0.0442515775 
          128           129           130           131           132 
-0.0716834586 -0.0923195985 -0.0852637027 -0.0557165056 -0.0469824374 
          133           134           135           136           137 
-0.0376902275 -0.0097216227 -0.0063913362 -0.0140603169 -0.1439259170 
          138           139           140           141           142 
-0.0622523656 -0.0492775920 -0.1350334500 -0.0935958760 -0.0393081269 
          143           144           145           146           147 
-0.0108957728 -0.0721911774 -0.0619661107 -0.0342811982 -0.0301508867 
          148           149           150           151           152 
-0.0189971851 -0.0071818406 -0.0510733117 -0.0129418669 -0.0043006525 
          153           154           155           156           157 
-0.0267027839 -0.0106910863 -0.0183609692 -0.0301412721 -0.0395466595 
          158           159           160           161           162 
-0.0466933283 -0.0455072567 -0.0290325458 -0.0220423838 -0.0047621449 
          163           164           165           166           167 
-0.0171030570 -0.0384627168 -0.0360346940 -0.0150835252 -0.0025080775 
          168           169           170           171           172 
-0.0175635951 -0.0060320802 -0.0307019006 -0.0192824600 -0.0161778900 
          173           174           175           176           177 
-0.0602777297 -0.0357789448 -0.0282270560 -0.0080535986 -0.1089110121 
          178           179           180           181           182 
-0.1186520495 -0.1197863879 -0.1185839274 -0.0817273863 -0.0719070495 
          183           184           185           186           187 
-0.0585821325 -0.1118718612 -0.0958583248 -0.0827004164 -0.0784094761 
          188           189           190           191           192 
-0.0486076888 -0.0370891213 -0.0266732227 -0.0443021216 -0.1254962622 
          193           194           195           196           197 
-0.0481087856 -0.1445808583 -0.1443781663 -0.0230343274 -0.0249107755 
          198           199           200           201           202 
-0.0285721938 -0.0099448624 -0.0542925007 -0.0639229832 -0.0597981636 
          203           204           205           206           207 
-0.0222223968 -0.0355522487 -0.0160544521 -0.0075980877 -0.0593920403 
          208           209           210           211           212 
-0.0508669162 -0.0520914932 -0.0601277063 -0.0481826567 -0.0242863050 
          213           214           215           216           217 
-0.0076058838 -0.0114711458 -0.0422411902 -0.0403739429 -0.0100842948 
          218           219           220           221           222 
-0.0200663027 -0.0614761278 -0.0573112628 -0.0244347815 -0.0245604770 
          223 
 0.0004988371 
> 
> ml_recontruct_bio4$ace - reml_recontruct_bio4$ace
113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
213 214 215 216 217 218 219 220 221 222 223 
  0   0   0   0   0   0   0   0   0   0   0 
> ml_recontruct_bio4$ace - pgl_recontruct_bio4$ace
113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
213 214 215 216 217 218 219 220 221 222 223 
  0   0   0   0   0   0   0   0   0   0   0 
> pgl_recontruct_bio4$ace - reml_recontruct_bio4$ace
113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
213 214 215 216 217 218 219 220 221 222 223 
  0   0   0   0   0   0   0   0   0   0   0 
> 
> ml_recontruct_bio4$ace - ml_recon_bio4$ace
         113          114          115          116          117          118 
  188.065701   -73.842323    -7.898159   778.388920   894.611102  1771.999254 
         119          120          121          122          123          124 
 2135.714056  1989.031022  2236.834885  2540.248893   402.385217   348.329642 
         125          126          127          128          129          130 
  144.073856   159.101517   739.052493   371.349231  2971.131466  3709.883882 
         131          132          133          134          135          136 
 5950.598493  5737.728870    -9.827030  -850.009281   592.654852   121.357573 
         137          138          139          140          141          142 
  -46.804393  1468.014158  2217.088839  -285.602010   -44.878910  1250.181776 
         143          144          145          146          147          148 
 1912.986873 -1009.829757  -823.734222    97.229413   -88.906646  -345.763362 
         149          150          151          152          153          154 
 -978.014051  -895.482435   685.970740   218.287123 -2427.433601   453.887496 
         155          156          157          158          159          160 
  880.972864  -128.557534  -805.112784 -1554.706376 -1512.328698 -1032.804891 
         161          162          163          164          165          166 
 -587.232005 -1170.547660 -1145.399756 -1665.710962 -1594.710450 -2293.096093 
         167          168          169          170          171          172 
-2374.431280 -3315.712370 -3654.958445  -134.978031   -76.063628   140.401884 
         173          174          175          176          177          178 
 -645.475428   -78.961162   250.437417  -673.297998 -1426.531012 -1380.674845 
         179          180          181          182          183          184 
-1834.031732 -1890.763138 -2488.322741 -2593.207095 -2799.286726 -1977.043572 
         185          186          187          188          189          190 
-2302.277944 -2458.511609 -2006.017278 -1655.286031 -1836.365909 -1586.732493 
         191          192          193          194          195          196 
-2555.702694  -763.174126 -1686.730658    57.331920   106.561305  2450.037436 
         197          198          199          200          201          202 
 3035.067351  2544.626167  1822.026101   167.605536   326.970650   308.958509 
         203          204          205          206          207          208 
  888.418925    66.287254  -243.847812  -651.348741  -150.398541   355.501631 
         209          210          211          212          213          214 
  347.100910  1058.491765   612.885160   384.577813  -547.633884   856.660060 
         215          216          217          218          219          220 
  436.356086   372.487355 -1543.473737   698.568316  2026.110353  2347.368865 
         221          222          223 
 4217.678313  2848.154155 -3171.828714 
> reml_recontruct_bio4$ace - reml_recon_bio4$ace
          113           114           115           116           117 
-0.0034389632  0.1583322937  0.1455817232  0.0979205789  0.0929732098 
          118           119           120           121           122 
 0.0601789659  0.0740703635  0.0579343845  0.0384242455  0.0942240028 
          123           124           125           126           127 
 0.0902908422  0.0896803833  0.0895722980  0.0880541889  0.0442515773 
          128           129           130           131           132 
 0.0716834582  0.0923195971  0.0852637014  0.0557165051  0.0469824370 
          133           134           135           136           137 
 0.0376902184  0.0097216216  0.0063913358  0.0140603141  0.1439257597 
          138           139           140           141           142 
 0.0622523366  0.0492775761  0.1350332931  0.0935957859  0.0393080981 
          143           144           145           146           147 
 0.0108957586  0.0721911470  0.0619660905  0.0342811931  0.0301508830 
          148           149           150           151           152 
 0.0189971831  0.0071818400  0.0510732962  0.0129418631  0.0043006519 
          153           154           155           156           157 
 0.0267027777  0.0106906520  0.0183608022  0.0301411991  0.0395466473 
          158           159           160           161           162 
 0.0466933254  0.0455072543  0.0290325445  0.0220423830  0.0047621450 
          163           164           165           166           167 
 0.0171030563  0.0384627152  0.0360346926  0.0150835245  0.0025080774 
          168           169           170           171           172 
 0.0175635946  0.0060320802  0.0307018958  0.0192824592  0.0161778895 
          173           174           175           176           177 
 0.0602777064  0.0357789380  0.0282270518  0.0080535978  0.1089110073 
          178           179           180           181           182 
 0.1186520465  0.1197863863  0.1185839258  0.0817273853  0.0719070488 
          183           184           185           186           187 
 0.0585821318  0.1118718597  0.0958583237  0.0827004156  0.0784094752 
          188           189           190           191           192 
 0.0486076884  0.0370891211  0.0266732225  0.0443021211  0.1254962601 
          193           194           195           196           197 
 0.0481087850  0.1445808569  0.1443781649  0.0230343272  0.0249107276 
          198           199           200           201           202 
 0.0285721665  0.0099448535  0.0542923490  0.0639229035  0.0597981011 
          203           204           205           206           207 
 0.0222223791  0.0355522114  0.0160544332  0.0075980765  0.0593919572 
          208           209           210           211           212 
 0.0508668796  0.0520914702  0.0601276948  0.0481826514  0.0242863030 
          213           214           215           216           217 
 0.0076058834  0.0114711451  0.0422411874  0.0403739404  0.0100842942 
          218           219           220           221           222 
 0.0200663020  0.0614761212  0.0573112578  0.0244347800  0.0245604751 
          223 
-0.0004988401 
> pgl_recontruct_bio4$ace - pgls_recon_bio4$ace #REML y PGLS y ML (con reconstruct) iguales en todos los casos.
          113           114           115           116           117 
-1.837241e-06 -4.827407e-07 -1.646422e-07 -5.458605e-08 -3.304285e-08 
          118           119           120           121           122 
-1.075296e-08 -4.439244e-09 -2.754859e-09 -1.361514e-09 -1.709850e-09 
          123           124           125           126           127 
-7.057679e-10 -6.057235e-10 -4.065441e-10 -4.029062e-10 -2.546585e-10 
          128           129           130           131           132 
-4.483809e-10 -1.409717e-09 -1.256922e-09 -5.275069e-10 -3.565219e-10 
          133           134           135           136           137 
-9.156793e-09 -1.091394e-09 -3.619789e-10 -2.822162e-09 -1.573644e-07 
          138           139           140           141           142 
-2.898742e-08 -1.592252e-08 -1.568897e-07 -9.011183e-08 -2.884099e-08 
          143           144           145           146           147 
-1.421085e-08 -3.035166e-08 -2.019078e-08 -5.066795e-09 -3.649802e-09 
          148           149           150           151           152 
-1.953595e-09 -6.275513e-10 -1.544322e-08 -3.787136e-09 -6.066330e-10 
          153           154           155           156           157 
-6.161372e-09 -4.343174e-07 -1.670060e-07 -7.294420e-08 -1.222361e-08 
          158           159           160           161           162 
-2.873094e-09 -2.444722e-09 -1.324224e-09 -8.703864e-10  7.275958e-11 
          163           164           165           166           167 
-6.912160e-10 -1.623448e-09 -1.347871e-09 -7.253220e-10 -5.275069e-11 
          168           169           170           171           172 
-5.393304e-10  2.182787e-11 -4.762114e-09 -8.158167e-10 -5.047696e-10 
          173           174           175           176           177 
-2.330671e-08 -6.805749e-09 -4.258254e-09 -8.249117e-10 -4.787580e-09 
          178           179           180           181           182 
-2.974957e-09 -1.660283e-09 -1.619810e-09 -9.690666e-10 -7.789822e-10 
          183           184           185           186           187 
-6.543814e-10 -1.432454e-09 -1.094577e-09 -8.658390e-10 -9.058567e-10 
          188           189           190           191           192 
-4.529284e-10 -2.405613e-10 -1.709850e-10 -4.247340e-10 -2.065462e-09 
          193           194           195           196           197 
-6.448317e-10 -1.416993e-09 -1.384251e-09 -1.291482e-10 -4.783578e-08 
          198           199           200           201           202 
-2.725210e-08 -8.879397e-09 -1.516628e-07 -7.976359e-08 -6.250139e-08 
          203           204           205           206           207 
-1.772241e-08 -3.734658e-08 -1.892295e-08 -1.120679e-08 -8.307688e-08 
          208           209           210           211           212 
-3.662717e-08 -2.292654e-08 -1.150693e-08 -5.256879e-09 -1.962690e-09 
          213           214           215           216           217 
-4.238245e-10 -7.366907e-10 -2.813977e-09 -2.456545e-09 -6.657501e-10 
          218           219           220           221           222 
-6.957634e-10 -6.559276e-09 -5.020411e-09 -1.491571e-09 -1.829903e-09 
          223 
-2.968136e-09 
> 
> #OU 
> pgls_ou_bio4 = reconstruct(bio4_vector, tree_prunned, method = "GLS_OU", alpha = 0.076650, CI = TRUE)
> pgls_ous_bio4 = reconstruct(bio4_vector, tree_prunned, method = "GLS_OUS", alpha = 0.076650, CI = TRUE) #"GLS_OU" and "GLS_OUS" differs in the fact that "GLS_OUS" assume that the process starts from the optimum, while the root state has to be estimated for "GLS_OU", which may rise some issues (see reconstruct 219 Royer-Carenzi and Didier, 2016). Users may provide the attractive strength parameter alpha, for these two models. Users may provide the attractive strength parameter alpha, for these two models. "GLS_ABM", "GLS_OU" and "GLS_OUS" are all fitted by generalized least squares (Royer-Carenzi and Didier, 2016).
>     #Note: GLS_OU may lead to aberrant reconstructions.
> 
> ## bio17
> # BM
> ml_recon_bio17 = ace(x=bio17_vector, phy=tree_prunned, type="continuous", method = "ML", CI = TRUE, model="BM", marginal=FALSE) 
Warning message:
In sqrt(diag(solve(h))) : NaNs produced
> reml_recon_bio17 = ace(x=bio17_vector, phy=tree_prunned, type="continuous", method = "REML", CI = TRUE, model="BM", marginal=FALSE)
> pgls_recon_bio17 = ace(x=bio17_vector, phy=tree_prunned, type="continuous", method = "GLS", CI = TRUE, model="BM", marginal=FALSE, corStruct = corBrownian(1, phy = tree_prunned))
>     #ML no estima el 95CI y además el manual de ape dice que ML puede dar estimar con bias en rasgos continuos: "It could be shown that, with a continous character, REML results in unbiased estimates of the variance of the Brownian motion process while ML gives a downward bias. Therefore the former is recommanded". 
> 
> # BM with reconstruct (APE)
> ml_recontruct_bio17 = reconstruct(bio17_vector, tree_prunned, method = "ML", alpha = NULL, CI = TRUE)
> reml_recontruct_bio17 = reconstruct(bio17_vector, tree_prunned, method = "REML", alpha = NULL, CI = TRUE)
> pgl_recontruct_bio17 = reconstruct(bio17_vector, tree_prunned, method = "GLS", alpha = NULL, CI = TRUE)
> 
> #compare ancestral states of BM all models
> ml_recon_bio17$ace - reml_recon_bio17$ace
         113          114          115          116          117          118 
  20.9717132   31.8156872  -15.3477262  -24.3274036  -31.7075864  -59.4918903 
         119          120          121          122          123          124 
 -35.5021332   -9.0154556   -7.7841942  -11.9289007   46.0710181   19.6222814 
         125          126          127          128          129          130 
  55.3675744   58.3852282  -14.6282795   44.7633910   -2.6685996   -3.5335007 
         131          132          133          134          135          136 
  26.6531996   46.8451094  -17.9824005   16.7223061  -40.0633884   19.8997448 
         137          138          139          140          141          142 
 -16.5246618  -11.2038769   -9.6638189   86.8183949   80.8855207   40.5026460 
         143          144          145          146          147          148 
   6.0589584   84.0446445   70.5506021    5.9117281   -4.2360959  -12.0628425 
         149          150          151          152          153          154 
   7.8597608   42.1642804  -81.9001478   -0.2310178  -14.4944876    9.5353718 
         155          156          157          158          159          160 
   1.9264299   44.2015950   51.8234915    9.7913947    0.2212696   -6.1140334 
         161          162          163          164          165          166 
  -1.5095072   20.3355183   -1.4935176  -22.4463547   34.2897068  -21.1106895 
         167          168          169          170          171          172 
  14.0027847   11.9403574  -18.8179701  -58.0113254  -59.0726357  -55.9604603 
         173          174          175          176          177          178 
  26.0016216  -25.6380347   -0.6657416   43.5751357   10.7388878   11.3746667 
         179          180          181          182          183          184 
 -16.1710615  -12.3162766  -14.8416949    1.8832500   -8.2647767   10.3705350 
         185          186          187          188          189          190 
 -10.1757681   -1.7295735  -10.6177839   19.2989512    6.6862889   17.5904564 
         191          192          193          194          195          196 
 -13.3193711   21.2253900  -19.3449640   36.4223168   33.8626295  -26.9760740 
         197          198          199          200          201          202 
 -43.8983229  -31.2803851   14.4626089   14.7565184   52.3499353   56.8492881 
         203          204          205          206          207          208 
   7.0475642   58.2746804   42.0384520   25.7815498  -27.3668353  -58.7073893 
         209          210          211          212          213          214 
 -81.2316414 -103.3010922  -80.1958862   -0.1790828  -12.0175418    2.7010902 
         215          216          217          218          219          220 
 -24.0966699  -13.8460926   30.1124314   85.8195599  -67.3418422  -44.8520318 
         221          222          223 
  46.8655145  -11.2716244   -1.3780316 
> ml_recon_bio17$ace - pgls_recon_bio17$ace
         113          114          115          116          117          118 
  20.9191877   31.7740922  -15.3926473  -24.3453698  -31.7199705  -59.4973490 
         119          120          121          122          123          124 
 -35.5085274   -9.0212058   -7.7884279  -11.9356529   46.0647481   19.6160920 
         125          126          127          128          129          130 
  55.3619710   58.3797709  -14.6314493   44.7580550   -2.6750398   -3.5394890 
         131          132          133          134          135          136 
  26.6491812   46.8418642  -17.9883587   16.7218856  -40.0634711   19.8982419 
         137          138          139          140          141          142 
 -16.5692577  -11.2126880   -9.6686891   86.8020290   80.8740011   40.4973257 
         143          144          145          146          147          148 
   6.0541365   84.0392811   70.5466405    5.9100722   -4.2375269  -12.0635741 
         149          150          151          152          153          154 
   7.8594889   42.1615219  -81.8996508   -0.2312020  -14.4948997    9.5366515 
         155          156          157          158          159          160 
   1.9205581   44.1906287   51.8195789    9.7868956    0.2168040   -6.1170654 
         161          162          163          164          165          166 
  -1.5119009   20.3350973   -1.4953882  -22.4499547   34.2863088  -21.1113383 
         167          168          169          170          171          172 
  14.0031934   11.9389652  -18.8185654  -58.0129625  -59.0735787  -55.9611759 
         173          174          175          176          177          178 
  25.9898220  -25.6491808   -0.6759985   43.5737573   10.7351353   11.3717850 
         179          180          181          182          183          184 
 -16.1733449  -12.3184495  -14.8458962    1.8788196   -8.2694104   10.3694397 
         185          186          187          188          189          190 
 -10.1751259   -1.7282029  -10.6155108   19.3022500    6.6896404   17.5931522 
         191          192          193          194          195          196 
 -13.3158824   21.2222717  -19.3452305   36.4185051   33.8588091  -26.9765053 
         197          198          199          200          201          202 
 -43.9146239  -31.2907018   14.4655924   14.7712281   52.3470424   56.8439328 
         203          204          205          206          207          208 
   7.0332182   58.2760791   42.0370910   25.7767258  -27.3549953  -58.7056301 
         209          210          211          212          213          214 
 -81.2292782 -103.2978342  -80.1897019   -0.1764765  -12.0169337    2.7018901 
         215          216          217          218          219          220 
 -24.0893096  -13.8383319   30.1198227   85.8208563  -67.3410066  -44.8522718 
         221          222          223 
  46.8696306  -11.2644886   -1.3774149 
> reml_recon_bio17$ace - pgls_recon_bio17$ace
          113           114           115           116           117 
-5.252557e-02 -4.159496e-02 -4.492107e-02 -1.796620e-02 -1.238408e-02 
          118           119           120           121           122 
-5.458716e-03 -6.394231e-03 -5.750214e-03 -4.233649e-03 -6.752223e-03 
          123           124           125           126           127 
-6.270003e-03 -6.189344e-03 -5.603398e-03 -5.457357e-03 -3.169827e-03 
          128           129           130           131           132 
-5.335987e-03 -6.440126e-03 -5.988273e-03 -4.018395e-03 -3.245219e-03 
          133           134           135           136           137 
-5.958198e-03 -4.205479e-04 -8.267836e-05 -1.502852e-03 -4.459592e-02 
          138           139           140           141           142 
-8.811135e-03 -4.870190e-03 -1.636591e-02 -1.151953e-02 -5.320237e-03 
          143           144           145           146           147 
-4.821908e-03 -5.363354e-03 -3.961563e-03 -1.655829e-03 -1.431019e-03 
          148           149           150           151           152 
-7.316208e-04 -2.719336e-04 -2.758557e-03  4.970890e-04 -1.841871e-04 
          153           154           155           156           157 
-4.121078e-04  1.279689e-03 -5.871880e-03 -1.096634e-02 -3.912659e-03 
          158           159           160           161           162 
-4.499050e-03 -4.465698e-03 -3.031959e-03 -2.393742e-03 -4.209994e-04 
          163           164           165           166           167 
-1.870526e-03 -3.600010e-03 -3.398001e-03 -6.488718e-04  4.087293e-04 
          168           169           170           171           172 
-1.392187e-03 -5.952682e-04 -1.637115e-03 -9.429221e-04 -7.155953e-04 
          173           174           175           176           177 
-1.179960e-02 -1.114613e-02 -1.025682e-02 -1.378356e-03 -3.752475e-03 
          178           179           180           181           182 
-2.881763e-03 -2.283429e-03 -2.172873e-03 -4.201293e-03 -4.430377e-03 
          183           184           185           186           187 
-4.633753e-03 -1.095226e-03  6.422436e-04  1.370591e-03  2.273097e-03 
          188           189           190           191           192 
 3.298817e-03  3.351521e-03  2.695779e-03  3.488640e-03 -3.118349e-03 
          193           194           195           196           197 
-2.665253e-04 -3.811649e-03 -3.820365e-03 -4.313486e-04 -1.630093e-02 
          198           199           200           201           202 
-1.031666e-02  2.983476e-03  1.470973e-02 -2.892926e-03 -5.355341e-03 
          203           204           205           206           207 
-1.434598e-02  1.398644e-03 -1.361040e-03 -4.823944e-03  1.183998e-02 
          208           209           210           211           212 
 1.759191e-03  2.363162e-03  3.257945e-03  6.184302e-03  2.606316e-03 
          213           214           215           216           217 
 6.080840e-04  7.999803e-04  7.360302e-03  7.760736e-03  7.391344e-03 
          218           219           220           221           222 
 1.296344e-03  8.355789e-04 -2.400524e-04  4.116155e-03  7.135752e-03 
          223 
 6.167384e-04 
> 
> ml_recontruct_bio17$ace - reml_recontruct_bio17$ace
113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
213 214 215 216 217 218 219 220 221 222 223 
  0   0   0   0   0   0   0   0   0   0   0 
> ml_recontruct_bio17$ace - pgl_recontruct_bio17$ace
113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
213 214 215 216 217 218 219 220 221 222 223 
  0   0   0   0   0   0   0   0   0   0   0 
> pgl_recontruct_bio17$ace - reml_recontruct_bio17$ace
113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 
  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 
213 214 215 216 217 218 219 220 221 222 223 
  0   0   0   0   0   0   0   0   0   0   0 
> 
> ml_recontruct_bio17$ace - ml_recon_bio17$ace
        113         114         115         116         117         118 
-20.9191877 -31.7740922  15.3926473  24.3453698  31.7199705  59.4973490 
        119         120         121         122         123         124 
 35.5085274   9.0212058   7.7884279  11.9356529 -46.0647481 -19.6160920 
        125         126         127         128         129         130 
-55.3619710 -58.3797709  14.6314493 -44.7580550   2.6750398   3.5394890 
        131         132         133         134         135         136 
-26.6491812 -46.8418642  17.9883587 -16.7218856  40.0634710 -19.8982419 
        137         138         139         140         141         142 
 16.5692577  11.2126880   9.6686891 -86.8020290 -80.8740011 -40.4973257 
        143         144         145         146         147         148 
 -6.0541365 -84.0392811 -70.5466405  -5.9100722   4.2375269  12.0635741 
        149         150         151         152         153         154 
 -7.8594889 -42.1615219  81.8996508   0.2312020  14.4948997  -9.5366515 
        155         156         157         158         159         160 
 -1.9205581 -44.1906287 -51.8195789  -9.7868956  -0.2168040   6.1170654 
        161         162         163         164         165         166 
  1.5119009 -20.3350973   1.4953882  22.4499547 -34.2863088  21.1113383 
        167         168         169         170         171         172 
-14.0031934 -11.9389652  18.8185654  58.0129625  59.0735787  55.9611759 
        173         174         175         176         177         178 
-25.9898220  25.6491808   0.6759985 -43.5737573 -10.7351353 -11.3717850 
        179         180         181         182         183         184 
 16.1733449  12.3184495  14.8458962  -1.8788196   8.2694104 -10.3694397 
        185         186         187         188         189         190 
 10.1751259   1.7282029  10.6155108 -19.3022500  -6.6896404 -17.5931522 
        191         192         193         194         195         196 
 13.3158824 -21.2222717  19.3452305 -36.4185051 -33.8588091  26.9765053 
        197         198         199         200         201         202 
 43.9146239  31.2907018 -14.4655924 -14.7712281 -52.3470424 -56.8439328 
        203         204         205         206         207         208 
 -7.0332182 -58.2760791 -42.0370910 -25.7767258  27.3549953  58.7056301 
        209         210         211         212         213         214 
 81.2292782 103.2978342  80.1897019   0.1764765  12.0169337  -2.7018901 
        215         216         217         218         219         220 
 24.0893096  13.8383319 -30.1198227 -85.8208563  67.3410066  44.8522718 
        221         222         223 
-46.8696306  11.2644886   1.3774149 
> reml_recontruct_bio17$ace - reml_recon_bio17$ace
          113           114           115           116           117 
 5.252554e-02  4.159495e-02  4.492107e-02  1.796620e-02  1.238408e-02 
          118           119           120           121           122 
 5.458715e-03  6.394231e-03  5.750213e-03  4.233649e-03  6.752223e-03 
          123           124           125           126           127 
 6.270003e-03  6.189344e-03  5.603398e-03  5.457357e-03  3.169827e-03 
          128           129           130           131           132 
 5.335987e-03  6.440126e-03  5.988273e-03  4.018395e-03  3.245219e-03 
          133           134           135           136           137 
 5.958198e-03  4.205479e-04  8.267835e-05  1.502852e-03  4.459592e-02 
          138           139           140           141           142 
 8.811135e-03  4.870190e-03  1.636591e-02  1.151953e-02  5.320237e-03 
          143           144           145           146           147 
 4.821908e-03  5.363353e-03  3.961562e-03  1.655829e-03  1.431019e-03 
          148           149           150           151           152 
 7.316207e-04  2.719335e-04  2.758556e-03 -4.970891e-04  1.841871e-04 
          153           154           155           156           157 
 4.121076e-04 -1.279696e-03  5.871878e-03  1.096634e-02  3.912659e-03 
          158           159           160           161           162 
 4.499050e-03  4.465697e-03  3.031959e-03  2.393742e-03  4.209994e-04 
          163           164           165           166           167 
 1.870526e-03  3.600010e-03  3.398001e-03  6.488717e-04 -4.087293e-04 
          168           169           170           171           172 
 1.392187e-03  5.952682e-04  1.637115e-03  9.429221e-04  7.155953e-04 
          173           174           175           176           177 
 1.179960e-02  1.114613e-02  1.025682e-02  1.378356e-03  3.752474e-03 
          178           179           180           181           182 
 2.881763e-03  2.283429e-03  2.172873e-03  4.201293e-03  4.430377e-03 
          183           184           185           186           187 
 4.633753e-03  1.095226e-03 -6.422437e-04 -1.370591e-03 -2.273097e-03 
          188           189           190           191           192 
-3.298817e-03 -3.351521e-03 -2.695779e-03 -3.488640e-03  3.118349e-03 
          193           194           195           196           197 
 2.665253e-04  3.811649e-03  3.820365e-03  4.313486e-04  1.630093e-02 
          198           199           200           201           202 
 1.031666e-02 -2.983476e-03 -1.470974e-02  2.892924e-03  5.355340e-03 
          203           204           205           206           207 
 1.434598e-02 -1.398645e-03  1.361040e-03  4.823944e-03 -1.183999e-02 
          208           209           210           211           212 
-1.759192e-03 -2.363162e-03 -3.257946e-03 -6.184302e-03 -2.606316e-03 
          213           214           215           216           217 
-6.080840e-04 -7.999803e-04 -7.360302e-03 -7.760736e-03 -7.391344e-03 
          218           219           220           221           222 
-1.296344e-03 -8.355790e-04  2.400523e-04 -4.116155e-03 -7.135752e-03 
          223 
-6.167385e-04 
> pgl_recontruct_bio17$ace - pgls_recon_bio17$ace #REML y PGLS y ML (con reconstruct) iguales en todos los casos. ML en ace no calcular el 95CI y además según el paquete mejor REML que ML.
          113           114           115           116           117 
-3.115758e-08 -8.191705e-09 -2.801073e-09 -9.343353e-10 -5.693153e-10 
          118           119           120           121           122 
-1.922160e-10 -8.336087e-11 -5.326228e-11 -3.166178e-11 -3.778666e-11 
          123           124           125           126           127 
-2.081890e-11 -2.006573e-11 -1.921308e-11 -1.753619e-11 -1.480949e-11 
          128           129           130           131           132 
-1.705303e-11 -3.437606e-11 -2.889067e-11 -1.563194e-11 -1.408296e-11 
          133           134           135           136           137 
-1.631406e-10 -2.535216e-11 -1.341505e-11 -5.402967e-11 -2.676643e-09 
          138           139           140           141           142 
-5.003074e-10 -2.785328e-10 -2.666582e-09 -1.531191e-09 -4.936851e-10 
          143           144           145           146           147 
-2.432330e-10 -5.219931e-10 -3.516334e-10 -9.572432e-11 -7.065637e-11 
          148           149           150           151           152 
-4.297362e-11 -2.103206e-11 -2.719958e-10 -7.429435e-11 -1.926992e-11 
          153           154           155           156           157 
-1.100489e-10 -7.370176e-09 -2.840068e-09 -1.247088e-09 -2.228262e-10 
          158           159           160           161           162 
-6.463097e-11 -5.667289e-11 -3.689138e-11 -2.853540e-11 -1.210765e-11 
          163           164           165           166           167 
-2.620482e-11 -4.285994e-11 -3.961986e-11 -2.864908e-11 -1.682565e-11 
          168           169           170           171           172 
-2.370371e-11 -1.466560e-11 -9.646328e-11 -2.847855e-11 -2.194156e-11 
          173           174           175           176           177 
-4.047820e-10 -1.264198e-10 -8.247980e-11 -2.148681e-11 -8.628831e-11 
          178           179           180           181           182 
-6.070877e-11 -3.586820e-11 -3.595346e-11 -2.393108e-11 -2.017941e-11 
          183           184           185           186           187 
-1.716671e-11 -3.518608e-11 -2.643219e-11 -2.398792e-11 -2.356160e-11 
          188           189           190           191           192 
-1.364242e-11 -1.244871e-11 -1.227818e-11 -1.665512e-11 -4.581580e-11 
          193           194           195           196           197 
-2.120260e-11 -3.495870e-11 -3.544187e-11 -1.263345e-11 -8.185452e-10 
          198           199           200           201           202 
-4.693561e-10 -1.566463e-10 -2.578417e-09 -1.360775e-09 -1.067406e-09 
          203           204           205           206           207 
-3.084324e-10 -6.398864e-10 -3.298055e-10 -1.973035e-10 -1.408978e-09 
          208           209           210           211           212 
-6.247092e-10 -3.911680e-10 -1.987530e-10 -9.364953e-11 -3.707612e-11 
          213           214           215           216           217 
-9.265477e-12 -1.699618e-11 -5.206857e-11 -4.471445e-11 -1.502087e-11 
          218           219           220           221           222 
-1.627143e-11 -1.129337e-10 -8.893153e-11 -3.026202e-11 -3.450396e-11 
          223 
-5.093170e-11 
> 
> #OU 
> pgls_ou_bio17 = reconstruct(bio17_vector, tree_prunned, method = "GLS_OU", alpha = 0.027591, CI = TRUE)
> pgls_ous_bio17 = reconstruct(bio17_vector, tree_prunned, method = "GLS_OUS", alpha = 0.027591, CI = TRUE) #Mas alto ape
> 
> # OU en ape vs OU en compare 4.6 (SE and Adj.SE) in bio17
> abs(pgls_ous_bio17$CI95[,1] + (-pgls_ous_bio17$CI95[,2])) - anc_ou_bio17$SE
      113       114       115       116       117       118       119       120 
-46.44000 361.58416 331.90213 277.22002 248.76137 192.54968 145.91310 149.29989 
      121       122       123       124       125       126       127       128 
142.86221 116.47972 102.47668  99.31234  98.94993  99.54693 104.32816 109.36703 
      129       130       131       132       133       134       135       136 
116.72544 119.54205 116.32367 113.93309 199.18672 104.42872  77.86763 150.92357 
      137       138       139       140       141       142       143       144 
332.34263 242.82103 213.57075 327.92320 312.70170 248.19937 213.58194 226.95616 
      145       146       147       148       149       150       151       152 
207.02560 156.60477 145.51332 131.67355  95.92825 206.00748 155.60578  73.70035 
      153       154       155       156       157       158       159       160 
169.45417 352.94282 329.67693 289.13984 188.30739 123.06650 118.17824 119.23598 
      161       162       163       164       165       166       167       168 
125.22947  74.91818 127.09826 118.43985 124.82028 124.75937 101.38206 112.98792 
      169       170       171       172       173       174       175       176 
 73.80761 167.82561 104.78587  94.59488 224.75448 185.83529 173.23562 104.23777 
      177       178       179       180       181       182       183       184 
139.26180 120.64908 107.90040 106.79959 122.51167 125.73787 134.23688 107.52569 
      185       186       187       188       189       190       191       192 
122.43573 134.54908 119.26097 122.95303 120.78741 121.08860 138.15048 127.82602 
      193       194       195       196       197       198       199       200 
142.17457 133.37885 134.21988 103.28585 279.04471 250.77078 193.49453 318.38924 
      201       202       203       204       205       206       207       208 
303.34797 295.89165 255.98738 284.07859 258.71130 241.07181 304.31998 262.60559 
      209       210       211       212       213       214       215       216 
237.30923 201.18932 180.72967 166.46657 111.10175 138.62437 167.91796 168.26363 
      217       218       219       220       221       222       223 
136.38838 135.47828 194.06667 194.84033 162.27834 169.89953 110.44284 
> abs(pgls_ous_bio17$CI95[,1] + (-pgls_ous_bio17$CI95[,2])) - anc_ou_bio17$Adj.SE #range of pgls_ous are broader than SE and Adj.SE
      113       114       115       116       117       118       119       120 
-46.44000 501.69416 449.36213 362.07002 316.69137 232.47968 160.75310 163.29989 
      121       122       123       124       125       126       127       128 
147.67221 113.98972  94.55668  89.50234  88.26993  88.92693  90.50816 103.45703 
      129       130       131       132       133       134       135       136 
112.76544 114.19205  91.46367  84.70309 220.37672  73.78872  29.82763 126.75357 
      137       138       139       140       141       142       143       144 
449.71263 297.53103 250.13075 437.19320 407.45170 300.52937 240.99194 276.05616 
      145       146       147       148       149       150       151       152 
245.33560 161.09477 142.72332 120.65355  66.04825 242.78748 157.61578  36.56035 
      153       154       155       156       157       158       159       160 
171.04417 489.14282 445.05693 389.42984 229.81739 129.54650 121.89824 119.63598 
      161       162       163       164       165       166       167       168 
125.78947  36.62818 125.96826 121.72985 130.86028 127.08937  85.11206 102.31792 
      169       170       171       172       173       174       175       176 
 36.65761 189.44561  86.17587  69.10488 286.06448 207.97529 181.58562  84.39777 
      177       178       179       180       181       182       183       184 
156.41180 127.99908 108.76040 107.12959 128.58167 131.65787 142.60688 108.20569 
      185       186       187       188       189       190       191       192 
129.99573 147.89908 123.68097 123.31303 117.04741 112.00860 145.26048 135.53602 
      193       194       195       196       197       198       199       200 
146.60457 138.75885 139.75988  62.97585 333.91471 288.22078 202.20453 426.86924 
      201       202       203       204       205       206       207       208 
398.90797 385.25165 308.58738 363.09859 320.25130 295.28181 401.76998 331.63559 
      209       210       211       212       213       214       215       216 
294.08923 236.74932 206.82967 179.59657  85.96175 130.17437 184.94796 184.66363 
      217       218       219       220       221       222       223 
150.05838 130.73828 218.44667 216.63033 142.92834 160.02953  79.29284 
> 
> #differences between SE and Adj.SE in bio17
> median(anc_ou_bio17$SE)
[1] 64.98
> median(anc_ou_bio17$Adj.SE)
[1] 57.69
> wilcox.test(anc_ou_bio17$SE, anc_ou_bio17$Adj.SE)

	Wilcoxon rank sum test with continuity correction

data:  anc_ou_bio17$SE and anc_ou_bio17$Adj.SE
W = 7980, p-value = 0.0001439
alternative hypothesis: true location shift is not equal to 0

> plot(density(anc_ou_bio17$SE - anc_ou_bio17$Adj.SE)) 
> quantile(anc_ou_bio17$SE - anc_ou_bio17$Adj.SE, probs=c(0.025, 0.975))
    2.5%    97.5% 
-37.4350 117.3925 
> #CI95 overlap with zero, although significant the wilcoxon test
> 
> # OU en ape vs OU en compare 4.6 (SE and Adj.SE) in bio4
> abs(pgls_ous_bio4$CI95[,1] + (-pgls_ous_bio4$CI95[,2])) - anc_ou_bio4$SE
      113       114       115       116       117       118       119       120 
-1775.340  6987.811  6965.259  6727.951  6483.977  5508.719  4468.955  4526.342 
      121       122       123       124       125       126       127       128 
 4259.828  3674.739  3199.558  3112.928  3066.052  3075.456  3101.389  3334.143 
      129       130       131       132       133       134       135       136 
 3676.606  3724.315  3521.837  3424.995  5587.540  3037.984  2269.281  4390.183 
      137       138       139       140       141       142       143       144 
 6966.169  6295.649  5864.019  6952.386  6911.753  6396.552  5863.891  6220.706 
      145       146       147       148       149       150       151       152 
 5973.122  4691.596  4405.664  3950.549  2814.463  5937.309  4514.083  2135.268 
      153       154       155       156       157       158       159       160 
 4831.369  6986.954  6958.433  6798.488  5352.309  3859.500  3744.495  3712.999 
      161       162       163       164       165       166       167       168 
 3807.744  2175.442  3829.719  3725.762  3859.205  3761.334  2983.345  3323.113 
      169       170       171       172       173       174       175       176 
 2147.667  4891.127  3092.134  2792.035  6102.230  5391.435  5084.324  3027.848 
      177       178       179       180       181       182       183       184 
 4349.243  3940.413  3628.024  3602.291  3915.140  3980.433  4143.182  3606.542 
      185       186       187       188       189       190       191       192 
 3918.457  4169.436  3792.164  3799.813  3707.642  3652.944  4146.886  4093.279 
      193       194       195       196       197       198       199       200 
 4214.331  4210.912  4226.566  3017.998  6726.459  6464.878  5414.920  6963.688 
      201       202       203       204       205       206       207       208 
 6939.076  6918.598  6436.285  6848.916  6628.290  6377.417  6913.188  6677.163 
      209       210       211       212       213       214       215       216 
 6449.362  5989.704  5525.227  4950.129  3248.199  4095.428  5197.333  5176.002 
      217       218       219       220       221       222       223 
 4011.482  3975.458  5842.333  5797.966  4732.279  4928.744  3153.601 
> abs(pgls_ous_bio4$CI95[,1] + (-pgls_ous_bio4$CI95[,2])) - anc_ou_bio4$Adj.SE #range of pgls_ous are broader than SE and Adj.SE
      113       114       115       116       117       118       119       120 
-1775.340 11551.661 11517.979 11128.701 10711.257  9001.899  7147.855  7265.922 
      121       122       123       124       125       126       127       128 
 6786.818  5717.979  4910.078  4761.198  4686.512  4703.506  4767.709  5162.453 
      129       130       131       132       133       134       135       136 
 5714.946  5787.685  5348.357  5151.935  9089.120  4452.514  3088.891  6961.103 
      137       138       139       140       141       142       143       144 
11519.469 10423.469  9691.459 11498.556 11433.383 10569.282  9626.361 10295.916 
      145       146       147       148       149       150       151       152 
 9874.332  7586.596  7100.674  6323.909  4345.913  9819.039  7346.033  3192.768 
      153       154       155       156       157       158       159       160 
 7873.839 11549.344 11507.843 11255.768  8772.109  6098.650  5894.065  5835.759 
      161       162       163       164       165       166       167       168 
 5990.334  3134.252  6067.799  5859.222  6096.375  5918.894  4574.295  5150.723 
      169       170       171       172       173       174       175       176 
 3059.417  8012.527  4869.114  4338.775 10044.120  8850.605  8296.664  4761.258 
      177       178       179       180       181       182       183       184 
 6888.783  6155.943  5587.534  5540.921  6092.800  6217.893  6515.512  5546.212 
      185       186       187       188       189       190       191       192 
 6099.447  6541.926  5868.904  5870.303  5691.452  5574.854  6530.566  6439.109 
      193       194       195       196       197       198       199       200 
 6754.181  6646.122  6673.016  4452.148 11114.699 10672.758  8890.110 11509.508 
      201       202       203       204       205       206       207       208 
11469.756 11436.078 10581.725 11324.916 10964.570 10557.377 11427.028 11029.833 
      209       210       211       212       213       214       215       216 
10639.132  9850.394  9072.987  8034.389  4983.469  6522.828  8521.913  8486.502 
      217       218       219       220       221       222       223 
 6486.732  6370.238  9564.133  9481.166  7624.459  7851.344  4844.931 
> 
> #differences between SE and Adj.SE in bio4
> median(anc_ou_bio4$SE)
[1] 3225.31
> median(anc_ou_bio4$Adj.SE)
[1] 671.35
> wilcox.test(anc_ou_bio4$SE, anc_ou_bio4$Adj.SE)

	Wilcoxon rank sum test with continuity correction

data:  anc_ou_bio4$SE and anc_ou_bio4$Adj.SE
W = 12316, p-value < 2.2e-16
alternative hypothesis: true location shift is not equal to 0

> plot(density(anc_ou_bio4$SE - anc_ou_bio4$Adj.SE))
> quantile(anc_ou_bio4$SE - anc_ou_bio4$Adj.SE, probs=c(0.025, 0.975)) #CI95 does not overlap with zero, and significant the wilcoxon test
    2.5%    97.5% 
 947.045 4552.865 
> 
> 
> #decision
> #Adj.SE has lower values than SE, but as we are only to use BM, and we only want SE of OU to compare with SE of BM we are going to use the regular SE of compare, which probably is more similar to the SE of reconstruct According to comapre, SE is estimate with the Schluter et al. method, which may differ only slightly from Hansen method, the method used for reconstruct. Adj.SE correspond to the method of Rohlf (2001, Evolution 55:2143-2150), who proposed another way of estimating standard errors for ancestral states. We will use SE because of that.
> 
> #### final reconstructed variables ####
> anc_ou_bio4
    nodo1   State      SE  Adj.SE
1     113 6193.09 1775.34 1775.34
2     114 6200.76 5098.85  535.00
3     115 6243.94 5087.55  534.83
4     116 6415.80 4952.63  551.88
5     117 6520.18 4801.05  573.77
6     118 6925.37 4136.17  642.99
7     119 7172.76 3393.02  714.12
8     120 7050.99 3434.79  695.21
9     121 6937.89 3230.14  703.15
10    122 7337.65 2807.09  763.85
11    123 7009.23 2445.11  734.59
12    124 6986.66 2380.18  731.91
13    125 6919.73 2341.61  721.15
14    126 6911.19 2348.02  719.97
15    127 6811.09 2357.09  690.77
16    128 6927.69 2541.02  712.71
17    129 7389.89 2808.34  770.00
18    130 7464.19 2841.84  778.47
19    131 7792.29 2680.34  853.82
20    132 7810.46 2604.88  877.94
21    133 6239.24 4187.19  685.61
22    134 6051.70 2300.96  886.43
23    135 6131.47 1720.70  901.09
24    136 6241.60 3316.54  745.62
25    137 6239.99 5088.01  534.71
26    138 6269.03 4674.07  546.25
27    139 6312.46 4380.82  553.38
28    140 6192.15 5081.06  534.89
29    141 6212.76 5059.03  537.40
30    142 6303.68 4740.46  567.73
31    143 6375.25 4379.43  616.96
32    144 6113.27 4633.52  558.31
33    145 6127.14 4470.36  569.15
34    146 6214.06 3549.99  654.99
35    147 6197.04 3340.90  645.89
36    148 6175.34 2998.36  625.00
37    149 6146.60 2134.97  603.52
38    150 6124.36 4445.15  563.42
39    151 6226.16 3407.17  575.22
40    152 6209.63 1617.82  560.32
41    153 5950.06 3637.83  595.36
42    154 6184.91 5098.44  536.05
43    155 6128.06 5084.12  534.71
44    156 5915.66 4994.74  537.46
45    157 5640.76 4024.47  604.67
46    158 5375.36 2945.26  706.11
47    159 5373.68 2861.38  711.81
48    160 5479.49 2833.67  710.91
49    161 5568.70 2898.32  715.73
50    162 5700.70 1649.04  690.23
51    163 5560.02 2912.04  673.96
52    164 5362.73 2845.83  712.37
53    165 5388.50 2942.03  704.86
54    166 5376.34 2860.45  702.89
55    167 5471.07 2264.13  673.18
56    168 5318.47 2520.69  693.08
57    169 5310.26 1628.47  716.72
58    170 5866.66 3691.84  570.44
59    171 5988.10 2346.01  569.03
60    172 6003.92 2119.42  572.68
61    173 5645.32 4548.79  606.90
62    174 5973.27 4055.78  596.61
63    175 6037.47 3834.49  622.15
64    176 6052.21 2292.86  559.45
65    177 5167.14 3314.17  774.63
66    178 5104.52 3020.75  805.22
67    179 4957.91 2793.23  833.72
68    180 4945.78 2774.50  835.87
69    181 4935.78 2996.93  819.27
70    182 4957.39 3042.95  805.49
71    183 4999.72 3157.55  785.22
72    184 4933.83 2776.60  836.93
73    185 4957.15 3000.16  819.17
74    186 4995.85 3179.33  806.84
75    187 4969.56 2903.34  826.60
76    188 5082.22 2898.92  828.43
77    189 5118.33 2826.27  842.46
78    190 5208.50 2779.06  857.15
79    191 5103.69 3150.91  767.23
80    192 5285.79 3130.85  785.02
81    193 5543.39 3195.40  655.55
82    194 5467.00 3214.31  779.10
83    195 5479.83 3225.31  778.86
84    196 6188.17 2287.88  853.73
85    197 6375.88 4950.87  562.63
86    198 6374.38 4785.80  577.92
87    199 6355.03 4060.21  585.02
88    200 6205.34 5087.21  541.39
89    201 6205.44 5074.80  544.12
90    202 6205.29 5064.01  546.53
91    203 6244.75 4762.16  616.72
92    204 6196.43 5024.77  548.77
93    205 6189.96 4891.10  554.82
94    206 6180.85 4728.03  548.07
95    207 6217.92 5060.63  546.79
96    208 6288.90 4924.72  572.05
97    209 6322.73 4784.69  594.92
98    210 6441.47 4488.46  627.77
99    211 6359.21 4167.26  619.50
100   212 6229.91 3740.20  655.94
101   213 6087.83 2461.08  725.81
102   214 6231.93 3101.88  674.48
103   215 6351.92 3933.23  608.65
104   216 6345.24 3916.37  605.87
105   217 6209.77 3037.03  561.78
106   218 6352.70 3009.26  614.48
107   219 6570.91 4388.34  666.54
108   220 6596.33 4354.55  671.35
109   221 6762.68 3570.76  678.58
110   222 6652.87 3714.55  791.95
111   223 5741.41 2384.90  693.57
> anc_ou_bio17
    nodo1   State     SE Adj.SE
1     113 -244.14  46.44  46.44
2     114 -258.68 167.39  27.28
3     115 -208.28 152.38  34.92
4     116 -178.14 128.17  43.32
5     117 -166.68 115.52  47.59
6     118 -135.20  89.57  49.64
7     119 -115.17  68.05  53.21
8     120 -131.59  69.53  55.53
9     121 -123.96  66.41  61.60
10    122  -92.61  54.36  56.85
11    123  -93.56  47.75  55.67
12    124  -92.17  46.29  56.10
13    125  -88.96  46.08  56.76
14    126  -88.55  46.35  56.97
15    127  -85.10  48.44  62.26
16    128  -94.53  50.86  56.77
17    129  -90.55  54.46  58.42
18    130  -87.18  55.72  61.07
19    131  -82.04  54.09  78.95
20    132  -83.13  52.94  82.17
21    133 -198.66  92.50  71.31
22    134 -279.10  48.42  79.06
23    135 -289.48  36.09  84.13
24    136 -163.86  70.08  94.25
25    137 -208.28 152.50  35.13
26    138 -174.67 112.31  57.60
27    139 -179.39  99.11  62.55
28    140 -329.93 150.25  40.98
29    141 -332.50 143.59  48.84
30    142 -350.92 114.93  62.60
31    143 -354.88  99.15  71.74
32    144 -374.46 105.53  56.43
33    145 -381.75  96.61  58.30
34    146 -352.01  72.93  68.44
35    147 -346.68  67.78  70.57
36    148 -334.96  61.23  72.25
37    149 -318.82  44.49  74.37
38    150 -387.66  96.06  59.28
39    151 -413.09  72.25  70.24
40    152 -418.02  34.15  71.29
41    153 -337.41  78.62  77.03
42    154 -229.22 163.88  27.68
43    155 -229.91 151.24  35.86
44    156 -279.38 133.37  33.08
45    157 -375.03  87.44  45.93
46    158 -362.59  57.41  50.93
47    159 -362.58  55.17  51.45
48    160 -358.98  55.57  55.17
49    161 -353.44  58.25  57.69
50    162 -340.38  34.71  73.00
51    163 -356.77  59.08  60.21
52    164 -361.14  55.25  51.96
53    165 -359.80  58.14  52.10
54    166 -354.75  58.00  55.67
55    167 -348.98  47.03  63.30
56    168 -329.81  52.42  63.09
57    169 -320.96  34.20  71.35
58    170 -404.10  77.98  56.36
59    171 -419.20  48.63  67.24
60    172 -420.28  43.90  69.39
61    173 -261.79 104.33  43.02
62    174 -284.34  86.46  64.32
63    175 -271.54  80.60  72.25
64    176 -339.94  48.33  68.17
65    177 -230.52  64.98  47.83
66    178 -226.45  56.45  49.10
67    179 -234.83  50.57  49.71
68    180 -235.94  50.07  49.74
69    181 -249.00  57.19  51.12
70    182 -253.31  58.67  52.75
71    183 -256.37  62.52  54.15
72    184 -237.48  50.38  49.70
73    185 -245.01  57.17  49.61
74    186 -249.37  62.68  49.33
75    187 -235.77  55.63  51.21
76    188 -217.60  57.25  56.89
77    189 -214.89  56.21  59.95
78    190 -205.98  56.29  65.37
79    191 -258.63  64.21  57.10
80    192 -210.58  59.71  52.00
81    193 -248.53  66.03  61.60
82    194 -187.31  62.26  56.88
83    195 -186.08  62.63  57.09
84    196 -127.64  47.89  88.20
85    197 -143.99 128.81  73.94
86    198 -133.54 116.22  78.77
87    199 -139.88  89.81  81.10
88    200 -221.97 147.35  38.87
89    201 -267.48 140.72  45.16
90    202 -282.19 137.47  48.11
91    203 -329.36 118.30  65.70
92    204 -297.01 131.92  52.90
93    205 -306.39 120.28  58.74
94    206 -301.26 112.03  57.82
95    207 -172.44 140.62  43.17
96    208 -108.31 122.04  53.01
97    209  -90.50 110.67  53.89
98    210  -66.08  94.21  58.65
99    211  -53.74  84.51  58.41
100   212  -95.93  77.47  64.34
101   213 -128.50  51.54  76.68
102   214 -117.92  64.39  72.84
103   215  -38.85  78.49  61.46
104   216  -41.08  78.59  62.19
105   217  -77.53  63.36  49.69
106   218  -19.74  62.90  67.64
107   219  -71.88  90.79  66.41
108   220  -73.26  91.00  69.21
109   221  -76.01  75.40  94.75
110   222 -118.52  78.94  88.81
111   223 -256.47  51.13  82.28
> pgls_recon_bio4

    Ancestral Character Estimation

Call: ace(x = bio4_vector, phy = tree_prunned, type = "continuous", 
    method = "GLS", CI = TRUE, model = "BM", corStruct = corBrownian(1, 
        phy = tree_prunned), marginal = FALSE)

$ace
      113       114       115       116       117       118       119       120 
 6050.131  5788.223  5854.167  6640.457  6756.676  7634.073  7997.779  7851.102 
      121       122       123       124       125       126       127       128 
 8098.962  8402.314  6264.403  6210.395  6006.113  6021.156  6601.172  6233.426 
      129       130       131       132       133       134       135       136 
 8833.202  9572.024 11812.829 11599.971  5852.238  5011.948  6454.856  5983.427 
      137       138       139       140       141       142       143       144 
 5815.253  7330.078  8079.194  5576.463  5817.181  7112.250  7775.085  4852.235 
      145       146       147       148       149       150       151       152 
 5038.331  5959.315  5773.154  5516.303  4883.972  4966.563  6548.064  6080.371 
      153       154       155       156       157       158       159       160 
 3434.570  6315.952  6743.038  5733.507  5056.952  4307.359  4349.736  4829.260 
      161       162       163       164       165       166       167       168 
 5274.861  4691.374  4716.630  4196.354  4267.331  3568.921  3487.498  2546.272 
      169       170       171       172       173       174       175       176 
 2206.680  5727.094  5785.979  6002.496  5216.590  5783.104  6112.516  5188.721 
      177       178       179       180       181       182       183       184 
 4435.514  4481.390  4028.042  3971.302  3373.710  3268.838  3062.710  3885.021 
      185       186       187       188       189       190       191       192 
 3559.758  3403.501  3856.048  4206.787  4025.650  4275.299  3306.290  5098.891 
      193       194       195       196       197       198       199       200 
 4175.277  5919.408  5968.639  8312.271  8897.155  8406.701  7684.115  6029.670 
      201       202       203       204       205       206       207       208 
 6189.038  6171.023  6750.494  5928.353  5618.219  5210.704  5711.666  6217.572 
      209       210       211       212       213       214       215       216 
 6209.155  6920.557  6474.950  6246.643  5314.392  6718.759  6298.421  6234.569 
      217       218       219       220       221       222       223 
 4318.521  6560.659  7888.175  8209.440 10079.856  8710.284  2690.051 

$CI95
         [,1]      [,2]
113  6050.131  6050.131
114  5780.919  5795.527
115  5848.105  5860.229
116  6635.244  6645.671
117  6752.008  6761.344
118  7630.326  7637.820
119  7994.935  8000.623
120  7848.152  7854.052
121  8096.092  8101.831
122  8400.035  8404.593
123  6262.371  6266.436
124  6208.429  6212.360
125  6004.141  6008.085
126  6019.168  6023.143
127  6599.045  6603.299
128  6231.229  6235.624
129  8830.914  8835.489
130  9569.664  9574.384
131 11810.489 11815.169
132 11597.669 11602.273
133  5848.311  5856.165
134  5009.809  5014.086
135  6453.252  6456.461
136  5980.390  5986.465
137  5809.163  5821.344
138  7325.330  7334.826
139  8075.019  8083.369
140  5570.173  5582.753
141  5811.211  5823.152
142  7107.458  7117.042
143  7770.915  7779.254
144  4847.920  4856.550
145  5034.450  5042.211
146  5956.236  5962.394
147  5770.289  5776.020
148  5513.665  5518.941
149  4882.006  4885.939
150  4962.646  4970.480
151  6544.933  6551.194
152  6078.848  6081.895
153  3431.160  3437.980
154  6308.972  6322.932
155  6736.714  6749.361
156  5727.980  5739.035
157  5053.232  5060.673
158  4304.956  4309.762
159  4347.437  4352.035
160  4826.904  4831.616
161  5272.352  5277.370
162  4689.826  4692.922
163  4714.072  4719.189
164  4194.032  4198.676
165  4264.859  4269.804
166  3566.409  3571.434
167  3485.422  3489.574
168  2543.964  2548.580
169  2205.156  2208.204
170  5723.742  5730.445
171  5783.846  5788.112
172  6000.565  6004.428
173  5212.233  5220.946
174  5779.460  5786.748
175  6109.097  6115.935
176  5186.583  5190.860
177  4432.806  4438.223
178  4479.079  4483.701
179  4025.992  4030.093
180  3969.275  3973.329
181  3371.317  3376.103
182  3266.374  3271.302
183  3060.047  3065.374
184  3882.971  3887.071
185  3557.366  3562.149
186  3400.834  3406.167
187  3853.701  3858.394
188  4204.339  4209.235
189  4023.239  4028.062
190  4272.858  4277.740
191  3303.506  3309.074
192  5096.410  5101.372
193  4172.404  4178.151
194  5916.808  5922.009
195  5966.019  5971.260
196  8310.151  8314.391
197  8891.797  8902.513
198  8401.903  8411.499
199  7680.285  7687.946
200  6023.942  6035.399
201  6183.695  6194.381
202  6165.834  6176.213
203  6745.467  6755.522
204  5923.203  5933.503
205  5613.411  5623.026
206  5206.110  5215.299
207  5706.050  5717.283
208  6212.724  6222.419
209  6204.784  6213.526
210  6916.844  6924.270
211  6471.514  6478.386
212  6243.345  6249.940
213  5312.120  5316.665
214  6715.961  6721.556
215  6295.208  6301.634
216  6231.329  6237.808
217  4315.759  4321.283
218  6557.912  6563.406
219  7884.532  7891.819
220  8205.725  8213.156
221 10076.604 10083.108
222  8706.885  8713.684
223  2687.774  2692.329

> pgls_recon_bio17 #For PGLS under BM we have to add corBrownian(1, phy = tree_prunned)

    Ancestral Character Estimation

Call: ace(x = bio17_vector, phy = tree_prunned, type = "continuous", 
    method = "GLS", CI = TRUE, model = "BM", corStruct = corBrownian(1, 
        phy = tree_prunned), marginal = FALSE)

$ace
       113        114        115        116        117        118        119 
-261.62760 -272.96045 -227.89935 -212.61385 -207.44224 -181.42593 -158.24503 
       120        121        122        123        124        125        126 
-180.19700 -125.35051 -118.87641 -105.91000  -96.79320  -67.50791  -64.39379 
       127        128        129        130        131        132        133 
 -13.79924  -95.51641 -114.70722 -106.31989  -87.15433  -82.83185 -229.87494 
       134        135        136        137        138        139        140 
-311.85730 -326.19155 -184.03899 -226.84665 -137.07480 -157.90941 -331.38905 
       141        142        143        144        145        146        147 
-341.29630 -381.67253 -388.28339 -358.72589 -366.30552 -339.87577 -332.75774 
       148        149        150        151        152        153        154 
-317.07298 -292.51194 -379.03887 -442.99888 -480.44522 -335.86959 -250.12541 
       155        156        157        158        159        160        161 
-238.32058 -287.95523 -369.47137 -345.96649 -346.21075 -344.38261 -338.94684 
       162        163        164        165        166        167        168 
-340.39426 -350.48407 -348.26070 -350.30865 -345.06897 -351.00519 -312.93793 
       169        170        171        172        173        174        175 
-309.57684 -421.56954 -453.03631 -457.97644 -282.14429 -322.87234 -299.44360 
       176        177        178        179        180        181        182 
-437.12929 -245.98708 -240.74976 -251.21979 -253.01413 -269.08882 -274.91722 
       183        184        185        186        187        188        189 
-277.70110 -256.17491 -269.27164 -276.95372 -255.51262 -226.37508 -228.59420 
       190        191        192        193        194        195        196 
-209.66125 -295.12500 -219.83969 -280.51165 -184.98015 -183.10836  -99.06391 
       197        198        199        200        201        202        203 
-141.98092 -128.53753 -125.27667 -256.48631 -300.70868 -317.71550 -386.62772 
       204        205        206        207        208        209        210 
-333.77553 -345.11244 -340.46636 -212.40781 -150.53992 -138.51394 -112.97992 
       211        212        213        214        215        216        217 
 -79.77895 -121.93150 -145.99468 -134.85147  -35.93194  -37.28977  -51.76407 
       218        219        220        221        222        223 
  84.60304 -117.12756 -107.85623  -63.84311 -170.74413 -278.55820 

$CI95
          [,1]       [,2]
113 -261.62760 -261.62760
114 -280.26442 -265.65648
115 -233.96159 -221.83711
116 -217.82700 -207.40071
117 -212.11060 -202.77389
118 -185.17269 -177.67916
119 -161.08864 -155.40142
120 -183.14703 -177.24697
121 -128.21961 -122.48142
122 -121.15509 -116.59774
123 -107.94254 -103.87745
124  -98.75902  -94.82739
125  -69.48013  -65.53568
126  -66.38128  -62.40629
127  -15.92645  -11.67203
128  -97.71400  -93.31882
129 -116.99428 -112.42016
130 -108.68000 -103.95979
131  -89.49416  -84.81450
132  -85.13357  -80.53014
133 -233.80222 -225.94766
134 -313.99546 -309.71915
135 -327.79559 -324.58752
136 -187.07624 -181.00173
137 -232.93724 -220.75606
138 -141.82277 -132.32684
139 -162.08450 -153.73432
140 -337.67924 -325.09886
141 -347.26651 -335.32609
142 -386.46452 -376.88054
143 -392.45275 -384.11403
144 -363.04086 -354.41091
145 -370.18622 -362.42482
146 -342.95476 -336.79677
147 -335.62312 -329.89237
148 -319.71102 -314.43495
149 -294.47848 -290.54540
150 -382.95563 -375.12210
151 -446.12911 -439.86865
152 -481.96826 -478.92218
153 -339.27926 -332.45993
154 -257.10546 -243.14536
155 -244.64401 -231.99715
156 -293.48286 -282.42761
157 -373.19179 -365.75095
158 -348.36953 -343.56345
159 -348.50953 -343.91197
160 -346.73886 -342.02635
161 -341.45562 -336.43806
162 -341.94268 -338.84584
163 -353.04289 -347.92526
164 -350.58314 -345.93827
165 -352.78098 -347.83631
166 -347.58140 -342.55655
167 -353.08124 -348.92913
168 -315.24605 -310.62980
169 -311.10088 -308.05281
170 -424.92124 -418.21784
171 -455.16911 -450.90350
172 -459.90782 -456.04506
173 -286.50080 -277.78778
174 -326.51632 -319.22836
175 -302.86236 -296.02483
176 -439.26805 -434.99053
177 -248.69532 -243.27884
178 -243.06069 -238.43882
179 -253.27059 -249.16900
180 -255.04106 -250.98720
181 -271.48183 -266.69581
182 -277.38153 -272.45291
183 -280.36448 -275.03772
184 -258.22494 -254.12489
185 -271.66309 -266.88019
186 -279.62018 -274.28727
187 -257.85893 -253.16630
188 -228.82330 -223.92686
189 -231.00575 -226.18264
190 -212.10194 -207.22057
191 -297.90890 -292.34110
192 -222.32043 -217.35896
193 -283.38555 -277.63775
194 -187.58086 -182.37943
195 -185.72892 -180.48780
196 -101.18364  -96.94418
197 -147.33931 -136.62252
198 -133.33580 -123.73925
199 -129.10745 -121.44588
200 -262.21453 -250.75809
201 -306.05206 -295.36530
202 -322.90535 -312.52564
203 -391.65500 -381.60044
204 -338.92537 -328.62569
205 -349.91996 -340.30491
206 -345.06091 -335.87182
207 -218.02422 -206.79140
208 -155.38706 -145.69278
209 -142.88525 -134.14262
210 -116.69305 -109.26679
211  -83.21471  -76.34320
212 -125.22887 -118.63413
213 -148.26714 -143.72223
214 -137.64905 -132.05389
215  -39.14534  -32.71854
216  -40.52924  -34.05031
217  -54.52599  -49.00215
218   81.85622   87.34985
219 -120.77091 -113.48420
220 -111.57151 -104.14095
221  -67.09492  -60.59131
222 -174.14343 -167.34483
223 -280.83591 -276.28050

> 
> #### plots the final models
> 
> ##check that the order of rows is correct
> summary(names(pgls_recon_bio4$ace) == anc_ou_bio4$nodo1)
   Mode    TRUE 
logical     111 
> summary(names(pgls_recon_bio17$ace) == anc_ou_bio17$nodo1)
   Mode    TRUE 
logical     111 
> 
> ## modify function to add error bars of ancestral state (errorbar.contMap), because of a problem in the calculation of ii and jj. There are problems when the lower limit of CI95 and the lower limit of the range of current values of the trait are both negatives. The function calculates the difference, but the resulting number is negative, so I have added an abs()
> #in "ancestral.states" you have to include an object with the state as ace and the CI95 as CI95. Typical ace object. 
> errorbar_contMap_modified = function (obj, user=FALSE, anc.states=NULL, ...){
+     if (hasArg(x)){
+         x <- list(...)$x
+     } else{
+         x <- setNames(sapply(1:Ntip(obj$tree), function(x, obj) {
+         ii <- which(obj$tree$edge[, 2] == x)
+         ss <- names(obj$tree$maps[[ii]][length(obj$tree$maps[[ii]])])
+         obj$lims[1] + as.numeric(ss)/(length(obj$cols) - 1) * 
+             diff(obj$lims)
+         }, obj = obj), obj$tree$tip.label)
+     }
+     if (hasArg(scale.by.ci)) {
+         scale.by.ci <- list(...)$scale.by.ci
+     } else {
+         scale.by.ci <- TRUE
+     }
+     if (hasArg(lwd)){
+         lwd <- list(...)$lwd
+     } else {
+         lwd <- 14
+     }
+     tree <- obj$tree
+     if(user==FALSE){
+         aa <- fastAnc(tree, x, CI = TRUE)
+     } else {
+         aa = anc.states
+     }
+     xlim <- range(aa$CI95)
+     if (xlim[2] > obj$lims[2] || xlim[1] < obj$lims[1]) {
+         cat(paste("  -----\n  The range of the contMap object, presently (", 
+             round(obj$lims[1], 4), ",", round(obj$lims[2], 4), 
+             "), should be equal to\n  or greater than the range of the CIs on ancestral states: (", 
+             round(xlim[1], 4), ",", round(xlim[2], 4), ").\n", 
+             sep = ""))
+         cat(paste("  To ensure that your error bars are correctly plotted, please recompute your\n", 
+             "  contMap object and increase lims.\n  -----\n", 
+             sep = ""))
+     }
+     d <- diff(obj$lims)
+     if (scale.by.ci) {
+         v <- aa$CI95[, 2] - aa$CI95[, 1]
+         v <- v/max(v)
+     } else {
+         v <- rep(0.5, tree$Nnode)
+     }    
+     n <- length(obj$cols) - 1
+     lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
+     h <- max(nodeHeights(tree))
+     for (i in 1:tree$Nnode) {
+         ii <- round((abs(aa$CI95[i, 1] - obj$lims[1]))/d * n)
+         jj <- round((abs(aa$CI95[i, 2] - obj$lims[1]))/d * (n + 1))
+         cols <- obj$cols[ii:jj]
+         add.color.bar(leg = 0.1 * h * v[i], cols = cols, prompt = FALSE, 
+             x = lastPP$xx[i + Ntip(tree)] - 0.05 * h * v[i], 
+             y = lastPP$yy[i + Ntip(tree)], title = "", subtitle = "", 
+             lims = NULL, lwd = lwd)
+     }
+ }
> 
> ##create a tree with species names as "P. XXXXX" to save space in the plots
> #before check that the order of the species names from climate_medians and tip.label of the tree is the same. 
> summary(tree_prunned$tip.label == paste("Pinus_", climate_medians$species, sep=""))
   Mode    TRUE 
logical     112 
> #copy the tree
> tree_prunned_to_plot = tree_prunned
> #add reduced names
> tree_prunned_to_plot$tip.label <- paste("P. ", climate_medians$species, sep="")
> 
> ##BM bio4
> #create a vector with the variable and species names as "P. XXXXX", similar to the tip.labels of tree_prunned_to_plot
> summary(names(bio4_vector) == paste("Pinus_", climate_medians$species, sep="")) #before check that the order of the species names from climate_medians and bio4_vector is the same. 
   Mode    TRUE 
logical     112 
> bio4_vector_to_plot = bio4_vector #copy the vector of the trait
> names(bio4_vector_to_plot) <- paste("P. ", climate_medians$species, sep="") #add reduced names
> 
> #open the pdf of the plot
> pdf("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/plot_anc/plot_ancestral_states_bm_bio4.pdf", width = 24, height = 24)
> 
> #create the tree interpolated
> obj_bm_bio4 = contMap(tree_prunned_to_plot, bio4_vector_to_plot, method="user", anc.states=pgls_recon_bio4$ace, plot=FALSE, lwd = 2) #aquí anc.states is a file with only ace, without 95CI.
> 
> #plot
> plot(obj_bm_bio4, type="fan", fsize=c(2.5, 2.3)) #fsize tiene el primer valor del tamaño de las tip labels, el segundo es para la legenda.
> 
> #add the error bars
> errorbar_contMap_modified(obj=obj_bm_bio4, user=TRUE, anc.states=pgls_recon_bio4, scale.by.ci=TRUE) #aquí anc.states is the complete file with ace and 95CI.
>     #scale.by.ci=TRUE: that determines whether or not the length of the error bars will be scaled by the CI width
> dev.off()
pdf 
  2 
> 
> 
> ##OU bio4
> #create a vector with the variable and species names as "P. XXXXX", similar to the tip.labels of tree_prunned_to_plot
> summary(names(bio4_vector) == paste("Pinus_", climate_medians$species, sep="")) #before check that the order of the species names from climate_medians and bio4_vector is the same. 
   Mode    TRUE 
logical     112 
> bio4_vector_to_plot = bio4_vector #copy the vector of the trait
> names(bio4_vector_to_plot) <- paste("P. ", climate_medians$species, sep="") #add reduced names
> 
> #create a list with ancestral state and CI95 of OU to plot
> ace_bio4_ou = anc_ou_bio4$State #extract acenstral state
> names(ace_bio4_ou) <- anc_ou_bio4$nodo1 #set names as node1
> CI95_bio4_ou = matrix(NA, ncol=2, nrow=nrow(anc_ou_bio4)) #create a matrix with 95CI
> CI95_bio4_ou[,1] <- anc_ou_bio4$State - anc_ou_bio4$SE #first column lower limit
> CI95_bio4_ou[,2] <- anc_ou_bio4$State + anc_ou_bio4$SE #second column upper limit
> row.names(CI95_bio4_ou) <- anc_ou_bio4$nodo1 #node1 as row.names
> anc_ou_bio4_to_plot = list() #bind all
> anc_ou_bio4_to_plot[["ace"]] <- ace_bio4_ou
> anc_ou_bio4_to_plot[["CI95"]] <- CI95_bio4_ou
> 
> #create the tree interpolated
> obj_ou_bio4 = contMap(tree_prunned_to_plot, bio4_vector_to_plot, method="user", anc.states=anc_ou_bio4_to_plot$ace, plot=FALSE, lwd = 2) #aquí anc.states is a file with only ace, without 95CI.
> 
> #open the pdf of the plot
> pdf("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/plot_anc/plot_ancestral_states_ou_bio4.pdf", width = 24, height = 24)
> 
> #plot
> plot(obj_ou_bio4, type="fan", fsize=c(2.5, 2.3)) #fsize tiene el primer valor del tamaño de las tip labels, el segundo es para la legenda.
> 
> #add the error bars
> errorbar_contMap_modified(obj=obj_ou_bio4, user=TRUE, anc.states=anc_ou_bio4_to_plot, scale.by.ci=TRUE) #aquí anc.states is the complete file with ace and 95CI.
  -----
  The range of the contMap object, presently (1373.7943,17394.998), should be equal to
  or greater than the range of the CIs on ancestral states: (920.92,11368.43).
  To ensure that your error bars are correctly plotted, please recompute your
  contMap object and increase lims.
  -----
>     #scale.by.ci=TRUE: that determines whether or not the length of the error bars will be scaled by the CI width
> dev.off()
pdf 
  2 
> 
> #plot for BM vs. OU comparison
> pdf("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/plot_anc/anc_bio4_bm_ou.pdf", width = 24, height = 11)
> par(mfrow=c(1,2))
> plot(obj_bm_bio4, type="phylogram", fsize=c(1, 2.3), xlim=c(-10,155), ftype="off",offset = 2.2)
> plot(obj_ou_bio4, type="phylogram", fsize=c(1, 2.3), xlim=c(-20,155), ftype="off", direction="leftwards") #fsize tiene el primer valor del tamaño de las tip labels, el segundo es para la legenda.
> dev.off()
pdf 
  2 
> 
> 
> ##BM bio17
> #create a vector with the variable and species names as "P. XXXXX", similar to the tip.labels of tree_prunned_to_plot
> summary(names(bio17_vector) == paste("Pinus_", climate_medians$species, sep="")) #before check that the order of the species names from climate_medians and bio17_vector is the same. 
   Mode    TRUE 
logical     112 
> bio17_vector_to_plot = bio17_vector #copy the vector of the trait
> names(bio17_vector_to_plot) <- paste("P. ", climate_medians$species, sep="") #add reduced names
> 
> #open the pdf of the plot
> pdf("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/plot_anc/plot_ancestral_states_bm_bio17.pdf", width = 24, height = 24)
> 
> #create the tree interpolated
> obj_bm_bio17 = contMap(tree_prunned_to_plot, bio17_vector_to_plot, method="user", anc.states=pgls_recon_bio17$ace, plot=FALSE, lwd = 2, res=10) #aquí anc.states is a file with only ace, without 95CI.
> 
> #plot
> plot(obj_bm_bio17, type="fan", fsize=c(2.5, 2.3)) #fsize tiene el primer valor del tamaño de las tip labels, el segundo es para la legenda.
> 
> #add the error bars
> errorbar_contMap_modified(obj=obj_bm_bio17, user=TRUE, anc.states=pgls_recon_bio17, scale.by.ci=TRUE) #aquí anc.states is the complete file with ace and 95CI.
>     #scale.by.ci=TRUE: that determines whether or not the length of the error bars will be scaled by the CI width
> dev.off()
pdf 
  2 
> 
> 
> ##OU bio17
> #create a vector with the variable and species names as "P. XXXXX", similar to the tip.labels of tree_prunned_to_plot
> summary(names(bio17_vector) == paste("Pinus_", climate_medians$species, sep="")) #before check that the order of the species names from climate_medians and bio17_vector is the same. 
   Mode    TRUE 
logical     112 
> bio17_vector_to_plot = bio17_vector #copy the vector of the trait
> names(bio17_vector_to_plot) <- paste("P. ", climate_medians$species, sep="") #add reduced names
> 
> #create a list with ancestral state and CI95 of OU to plot
> ace_bio17_ou = anc_ou_bio17$State #extract acenstral state
> names(ace_bio17_ou) <- anc_ou_bio17$nodo1 #set names as node1
> CI95_bio17_ou = matrix(NA, ncol=2, nrow=nrow(anc_ou_bio17)) #create a matrix with 95CI
> CI95_bio17_ou[,1] <- anc_ou_bio17$State - anc_ou_bio17$SE #first column lower limit
> CI95_bio17_ou[,2] <- anc_ou_bio17$State + anc_ou_bio17$SE #second column upper limit
> row.names(CI95_bio17_ou) <- anc_ou_bio17$nodo1 #node1 as row.names
> anc_ou_bio17_to_plot = list() #bind all
> anc_ou_bio17_to_plot[["ace"]] <- ace_bio17_ou
> anc_ou_bio17_to_plot[["CI95"]] <- CI95_bio17_ou
> 
> #create the tree interpolated
> obj_ou_bio17 = contMap(tree_prunned_to_plot, bio17_vector_to_plot, method="user", anc.states=anc_ou_bio17_to_plot$ace, plot=FALSE, lwd = 2) #aquí anc.states is a file with only ace, without 95CI.
> 
> #open the pdf of the plot
> pdf("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/plot_anc/plot_ancestral_states_ou_bio17.pdf", width = 24, height = 24)
> 
> #plot
> plot(obj_ou_bio17, type="fan", fsize=c(2.5, 2.3)) #fsize tiene el primer valor del tamaño de las tip labels, el segundo es para la legenda.
> 
> #add the error bars
> errorbar_contMap_modified(obj=obj_ou_bio17, user=TRUE, anc.states=anc_ou_bio17_to_plot, scale.by.ci=TRUE) #aquí anc.states is the complete file with ace and 95CI.
>     #scale.by.ci=TRUE: that determines whether or not the length of the error bars will be scaled by the CI width
> dev.off()
pdf 
  2 
> 
> #open the pdf of the plot
> pdf("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/plot_anc/plot_ancestral_states_bm_REML_bio17.pdf", width = 24, height = 24)
> 
> #create the tree interpolated
> obj_bm_bio17 = contMap(tree_prunned_to_plot, bio17_vector_to_plot, method="user", plot=FALSE, lwd = 2, anc.states=reml_recon_bio17$ace) #aquí anc.states is a file with only ace, without 95CI.
> 
> #plot
> plot(obj_bm_bio17, type="fan", fsize=c(2.5, 2.3)) #fsize tiene el primer valor del tamaño de las tip labels, el segundo es para la legenda.
> 
> #add the error bars
> errorbar_contMap_modified(obj=obj_bm_bio17, user=TRUE, anc.states=reml_recon_bio17, scale.by.ci=TRUE) #aquí anc.states is the complete file with ace and 95CI.
  -----
  The range of the contMap object, presently (-487.703,164.0171), should be equal to
  or greater than the range of the CIs on ancestral states: (-655.3805,172.61).
  To ensure that your error bars are correctly plotted, please recompute your
  contMap object and increase lims.
  -----
>     #scale.by.ci=TRUE: that determines whether or not the length of the error bars will be scaled by the CI width
> dev.off()
pdf 
  2 
> 
> #plot for BM vs. OU comparison
> pdf("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/plot_anc/anc_bio17_bm_ou.pdf", width = 24, height = 11)
> par(mfrow=c(1,2))
> plot(obj_bm_bio17, type="phylogram", fsize=c(1.45, 2.3), xlim=c(-10,155), ftype="off", offset = 2.2)
> plot(obj_ou_bio17, type="phylogram", fsize=c(1.45, 2.3), xlim=c(-20,155), ftype="off", direction="leftwards") #fsize tiene el primer valor del tamaño de las tip labels, el segundo es para la legenda.
> dev.off()
pdf 
  2 
> 
> 
> #Si recuerdas estoy estimando el estado ancestral bajo BM usando la función ace de APE. Pues bien, los intervalos de confianza de la estimas son extremadamente diferentes entre tipos de ajuste. Según PGLS los intervalos son muuuy estrechos, mientras que para REML son mucho más amplios (anchura del intervalo de 10 unidades en PGLS frente 300 en REML; con ML no se pueden llegar a calcular). Te adjunto dos plots con el estado ancestral de bio17 bajo REML y PGLS, las barritas en cada nodo indican el 95CI. He probado a calcular los estado ancestrales con la otra función de APE para esto, reconstruct, la cual se diferencia de ace en que "computations are not performed by numerical optimisation but through matrix calculus", pero se pueden usar los mismos tipos de ajuste (ML, REML y PGLS). En este caso salen los intervalos amplios para los tres casos. Por tanto, los intervalos muuuy estrechos solo salen en PGLS con ace.
> #No he encontrado reconstrucciones con tan poca incertidumbre en ninguno de los ejemplos que tiene Revell por la red, esto unido al hecho de que no se replican las diferencias entre ajustes cuando se repite todo con "reconstruct", me hace tener muy poca seguridad para usar esos intervalos "estrechos". Ante esto hay cuatro opciones: 
>     #Usar solo los modelos con intervalos estrechos. No me fío de esos intervalos, el extremo del intervalo podría estar ahí ó mucho más lejos.  
>     #Usar los intervalos de confianza obtenidos con PGLS en reconstruct, ó con REML en cualquiera de las dos funciones (ace - reconstruct). Estos intervalos me dan algo más seguridad, pero al haber tanta incertidumbre (intervalos amplios) el valor actual de muchas especies va a caer dentro del intervalo y por tanto no se va a poder hacer corregir la idoneidad por la filogenia (si no tenemos certeza de que el valor actual se diferencie del valor del último nodo, la amplitud del rango filogenético es 0).
>     #Usar todos los modelos (intervalos amplios y estrechos). Creo que esto no tiene mucho sentido, porque si para los casos con intervalos amplios no se puede corregir la idoneidad de hábitat por la filogenia, sería como estar usando solo los estrechos.
>     #Calcular la media de los dos intervalos (REML vs PGLS). Si el extremo superior de ambos modelos es 500 y 300 respectivamente, el "consenso" sería 400. No me convence, porque no me da seguridad ningún intervalo, así que el consenso de ellos no debe ser muy fiable. Para eso, aunque ampliemos más el rango filo, prefiero la siguiente opción. 
>     #NO usar los intervalos de confianza de las reconstrucciones. Es una putada no usar medida de incertidumbre pero creo que es la mejor opción dada la poca seguridad que tenemos sobre las 95CI. He comparados los valores de cada nodo (sin intervalos) y son prácticamente iguales entre todos los modelos y funciones (ace - reconstruct). Solo hay discrepancia entre ML de ace con el resto, pero esa reconstrucción era muy mala (ni se estima el 95CI) y de hecho en el manual de ape se desaconseja usarla. Si tomamos esta opción, el rango filogenético iría desde el valor del último nodo (sin incluirlo) hasta el valor actual (incluyéndolo). 
> #Todo esto aplica para bio17, en el caso de bio4 hay menos diferencias entre PGLS y REML, pero estas siguen siendo grandes: Anchura del intervalo de 10 unidades frente a 150. Por tanto, no podemos tener certeza de cuales son los intervalos. 
> 
> 
> #############################################
> ####### Comparsion of ancestral states ######
> #############################################
> ### Comparison of OU in comapre with SE of intraespecific variation and BM in ace without intraespecific variation
> 
> #number of nodes
> nrow(anc_ou_bio4)
[1] 111
> nrow(anc_ou_bio17)
[1] 111
> nrow(pgls_recon_bio4$CI95)
[1] 111
> nrow(pgls_recon_bio17$CI95)
[1] 111
> 
> #check that the order of nodes is the same
> summary(anc_ou_bio4$nodo1 == row.names(pgls_recon_bio4$CI95))
   Mode    TRUE 
logical     111 
> summary(anc_ou_bio17$nodo1 == row.names(pgls_recon_bio17$CI95))
   Mode    TRUE 
logical     111 
> 
> ###bio4
> pdf("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/comparison_bm_ou/comparsion_bm_ou_bio4.pdf")
> par(mfrow=c(2,2))
> 
> ##pannel 1
> #anc states  
> plot(anc_ou_bio4$State ~ pgls_recon_bio4$ace, xlab="Ancestral states under BM", ylab="Ancestral states under OU", main="")
> #cor between anc states
> spearman<-cor.test(anc_ou_bio4$State, pgls_recon_bio4$ace, method="spearman")
> mylabel = bquote(italic(rho) == .(format(spearman$estimate, digits = 3)))
> text(x=9500, y=5800, labels = mylabel, cex=1)
> if(!spearman$p.value == 0){ #if p.value is <2.2e-16, spearman save it as 0
+     mylabel.p = bquote(italic(p.value) == .(format(spearman$p.value, digits = 3)))
+ } else {
+     mylabel.p = bquote(italic(p.value) < .(format(2.2e-16)))
+ }
> text(x=9500, y=5500, labels = mylabel.p, cex=1)
> mylabel.t = bquote(italic(S) == .(format(spearman$statistic, digits = 3)))
> text(x=9500, y=5200, labels = mylabel.t, cex=1)
> 
> ##pannel 2
> if(FALSE){
+ #densitplot of differences between ancestral states
+     plot(density(abs(anc_ou_bio4$State - pgls_recon_bio4$ace)), main="Absolute difference ancestral states")
+     p<-wilcox.test(anc_ou_bio4$State, pgls_recon_bio4$ace)$p.value
+     mylabel.p = bquote(italic(p.value) == .(format(p, digits = 3)))
+     text(x=3000, y=0.0005, labels = mylabel.p, cex=1)
+ }
> 
> ##pannel 3
> #SE of OU versus CI95 of BM
> plot(anc_ou_bio4$SE~abs(pgls_recon_bio4$CI95[,1] - pgls_recon_bio4$CI95[,2]), xlab="Standard errors under BM", ylab="Standard errors under OU", main="")
> #cors
> spearman<-cor.test(anc_ou_bio4$SE, abs(pgls_recon_bio4$CI95[,1] - pgls_recon_bio4$CI95[,2]), method="spearman")
> mylabel = bquote(italic(rho) == .(format(spearman$estimate, digits = 3)))
> text(x=10, y=2700, labels = mylabel, cex=1)
> if(!spearman$p.value == 0){ #if p.value is <2.2e-16, spearman save it as 0
+     mylabel.p = bquote(italic(p.value) == .(format(spearman$p.value, digits = 3)))
+ } else {
+     mylabel.p = bquote(italic(p.value) < .(format(2.2e-16)))
+ }
> text(x=10, y=2400, labels = mylabel.p, cex=1)
> mylabel.t = bquote(italic(S) == .(format(spearman$statistic, digits = 3)))
> text(x=10, y=2100, labels = mylabel.t, cex=1)
> 
> 
> ##pannel 4
> if(FALSE){
+     #densitplot of differences between error of ancestral state estimates
+     plot(density(abs(anc_ou_bio4$SE - abs(pgls_recon_bio4$CI95[,1] - pgls_recon_bio4$CI95[,2]))), main="Absolute difference standard errors")
+     p<-wilcox.test(anc_ou_bio4$SE, abs(pgls_recon_bio4$CI95[,1] - pgls_recon_bio4$CI95[,2]))$p.value
+     mylabel.p = bquote(italic(p.value) == .(format(p, digits = 3)))
+     text(x=4800, y=0.0004, labels = mylabel.p, cex=1)
+ }
> dev.off()
pdf 
  2 
> 
> ###bio17
> pdf("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/comparison_bm_ou/comparsion_bm_ou_bio17.pdf")
> par(mfrow=c(2,2))
> 
> ##pannel 1
> #anc states  
> plot(anc_ou_bio17$State ~ pgls_recon_bio17$ace, xlab="Ancestral states under BM", ylab="Ancestral states under OU", main="")
> #cor between anc states
> spearman<-cor.test(anc_ou_bio17$State, pgls_recon_bio17$ace, method="spearman")
Warning message:
In cor.test.default(anc_ou_bio17$State, pgls_recon_bio17$ace, method = "spearman") :
  Cannot compute exact p-value with ties
> mylabel = bquote(italic(rho) == .(format(spearman$estimate, digits = 3)))
> text(x=-50, y=-300, labels = mylabel, cex=1)
> if(!spearman$p.value == 0){ #if p.value is <2.2e-16, spearman save it as 0
+     mylabel.p = bquote(italic(p.value) == .(format(spearman$p.value, digits = 3)))
+ } else {
+     mylabel.p = bquote(italic(p.value) < .(format(2.2e-16)))
+ }
> text(x=-50, y=-340, labels = mylabel.p, cex=1)
> mylabel.t = bquote(italic(S) == .(format(spearman$statistic, digits = 3)))
> text(x=-50, y=-380, labels = mylabel.t, cex=1)
> 
> ##pannel 2
> if(FALSE){
+     #densitplot of differences between ancestral states
+     plot(density(abs(anc_ou_bio17$State - pgls_recon_bio17$ace)), main="Absolute difference ancestral states")
+     p<-wilcox.test(anc_ou_bio17$State, pgls_recon_bio17$ace)$p.value
+     mylabel.p = bquote(italic(p.value) == .(format(p, digits = 3)))
+     text(x=3000, y=0.0005, labels = mylabel.p, cex=1)
+ } 
> 
> ##pannel 3
> #SE of OU versus CI95 of BM
> plot(anc_ou_bio17$SE~abs(pgls_recon_bio17$CI95[,1] - pgls_recon_bio17$CI95[,2]), xlab="Standard errors under BM", ylab="Standard errors under OU", main="")
> #cors
> spearman<-cor.test(anc_ou_bio17$SE, abs(pgls_recon_bio17$CI95[,1] - pgls_recon_bio17$CI95[,2]), method="spearman")
> mylabel = bquote(italic(rho) == .(format(spearman$estimate, digits = 3)))
> text(x=11, y=80, labels = mylabel, cex=1)
> if(!spearman$p.value == 0){ #if p.value is <2.2e-16, spearman save it as 0
+     mylabel.p = bquote(italic(p.value) == .(format(spearman$p.value, digits = 3)))
+ } else {
+     mylabel.p = bquote(italic(p.value) < .(format(2.2e-16)))
+ }
> text(x=11, y=65, labels = mylabel.p, cex=1)
> mylabel.t = bquote(italic(S) == .(format(spearman$statistic, digits = 3)))
> text(x=11, y=50, labels = mylabel.t, cex=1)
> 
> 
> ##pannel 4
> if(FALSE){
+     #densitplot of differences between error of ancestral state estimates
+     plot(density(abs(anc_ou_bio17$SE - abs(pgls_recon_bio17$CI95[,1] - pgls_recon_bio17$CI95[,2]))), main="Absolute difference standard errors")
+     p<-wilcox.test(anc_ou_bio17$SE, abs(pgls_recon_bio17$CI95[,1] - pgls_recon_bio17$CI95[,2]))$p.value
+     mylabel.p = bquote(italic(p.value) == .(format(p, digits = 3)))
+     text(x=4800, y=0.0004, labels = mylabel.p, cex=1)
+ }
> dev.off()
pdf 
  2 
> 
> ######Conclusions
> #Bio4: Como era de esperar por su valor de lambda tan alto (0.94), bio17 apenas muestra diferencias entre modelos. Los estados ancestrales están muy correlacionados (rho=0.98)  y no son significativamente diferentes (p = 0.4; panel 1 y 2). Los errores también están muy correlacionados, pero si hay diferencias entre modelos, siendo los errores de OU más grandes (esto creo que se debe más al programa [compare vs ace] que a los modelos). 
> #Bio17: En bio4 está la cosa un poco menos clara, lo cual es lógico viendo el valor de lambda no tan alto para esta variable (0.47). Sigue habiendo una correlación alta entre estados ancestrales (rho = 0.88), pero sí hay diferencias significativas entre modelos aunque con una p no muy baja (p = 0.03). Los errores de las estimaciones son significativamente muuucho más grandes en OU.
> #Yo creo que hay una correlación clara entre ambos modelos, se parecen mucho, y es lógico teniendo en cuenta los valores de lambda altos (sobre todo en bio17) y los valores de alfa tan bajos (0.08 para bio4 y 0.03 para bio17). Sin embargo, me preocupan un poco las diferencias en valor absoluto de los errores estándar para bio4, que al final es el parámetro que usamos y nos está dando resultados muy diferentes. La verdad es que no lo tengo claro, pero voy a seguir para adelante con BM. en caso de que hubiese que dar marcha atrás no va a ser mucho problema de trabajo, solo un poquito de tiempo para correr de nuevo los análisis.
> #Lo DEJO TODO PREPARADO PARA USAR OU TAMBIÉN, PERO NO LO VOY A USAR EN LAS FIGURAS, DEJO ABIERTA LA OPCIÓN PARA MÁS ADELANTE. 
> 
> 
> #####################################
> ####### calculate phylo ranges ######
> #####################################
> 
> ## Usamos PGLS aunque tengan interalos de confianza raros para BM, como no veíamos un simulitud entre los interalos de los diferentes ajustes para BM pasamos de usar interalos y usamos solo los estados ancestrales, los cuales son muuy parecidos entre ajusted bajo BM y además son muuy parecidos entre OU y BM. 
> 
> ## Calculo los rangos para OU también pero no lo vamos a usar finalmente. 
> 
> 
> ## check that all files (from compare and ape) has the same order and names of nodes
> summary(anc_ou_bio4$nodo1 == names(pgls_recon_bio4$ace))
   Mode    TRUE 
logical     111 
> summary(anc_ou_bio17$nodo1 == names(pgls_recon_bio17$ace))
   Mode    TRUE 
logical     111 
> 
> #extract intial and final node of all branches
> ramas = as.data.frame(tree_prunned$edge)
> colnames(ramas) <- c("nodo1", "nodo2")
> 
> ## create a variable final nodes of each species 
> #select branch in which are implicate terminal nodes (speices)
> final_ramas = ramas[which(ramas$nodo2 %in% 1:length(epithet_species_list)),]
> #reoder tree labels in basis on nodo2 positions
> species_ramas = tree_prunned$tip.label[final_ramas$nodo2]
> #bind
> final_ramas = cbind.data.frame(final_ramas, species_ramas)
> 
> ## check that each node2 has the correct species name
> summary(names(bio17_vector)[final_ramas$nodo2] == final_ramas$species_ramas) #all true
   Mode    TRUE 
logical     112 
> 
> ## create a new data.frame with current values of climate variables to merge with ancestral data
> climate_medians_merge = climate_medians
> climate_medians_merge$species = paste("Pinus_", climate_medians_merge$species, sep="")
> colnames(climate_medians_merge)[which(colnames(climate_medians_merge) == "species")] <- "species_ramas"
> climate_medians_merge_bio4 = climate_medians_merge[,which(colnames(climate_medians_merge) %in% c("species_ramas", "median_bio4"))]
> climate_medians_merge_bio17 = climate_medians_merge[,which(colnames(climate_medians_merge) %in% c("species_ramas", "median_bio17"))]
> 
> 
> #### bind final ramas with ancestral reconstructions from OU (compare) ####
> ## merge species names and anc data
> final_anc_ou_bio4 = merge(final_ramas, anc_ou_bio4, by="nodo1")
> final_anc_ou_bio17 = merge(final_ramas, anc_ou_bio17, by="nodo1")
> 
> ## check that each node has the correct ancestral value comparing with the raw data.frame of ancestrla reconstructions
> summary(anc_ou_bio4[which(anc_ou_bio4$nodo1 %in% final_anc_ou_bio4$nodo1),]$State == final_anc_ou_bio4[which(!duplicated(final_anc_ou_bio4$nodo1)),]$State)
   Mode    TRUE 
logical      77 
> summary(anc_ou_bio17[which(anc_ou_bio17$nodo1 %in% final_anc_ou_bio17$nodo1),]$State == final_anc_ou_bio17[which(!duplicated(final_anc_ou_bio17$nodo1)),]$State)
   Mode    TRUE 
logical      77 
> 
> ## bind current climatic data
> final_anc_ou_bio4 = merge(final_anc_ou_bio4, climate_medians_merge_bio4, by="species_ramas")
> final_anc_ou_bio17 = merge(final_anc_ou_bio17, climate_medians_merge_bio17, by="species_ramas")
> 
> ## check that current value is added correctly
> summary(climate_medians_merge[match(climate_medians_merge$species_ramas, final_anc_ou_bio17$species_ramas),]$species_ramas == final_anc_ou_bio17$species_ramas)
   Mode    TRUE 
logical     112 
> summary(climate_medians_merge[match(climate_medians_merge$species_ramas, final_anc_ou_bio4$species_ramas),]$species_ramas == final_anc_ou_bio4$species_ramas)
   Mode    TRUE 
logical     112 
> 
> ## reorder columns and set new col names
> #bio4
> final_anc_ou_bio4 = final_anc_ou_bio4[,c(1,3,7,2,4,5,6)]
> colnames(final_anc_ou_bio4) <- c("species", "node_species", "current_value", "node_antecesor", "ace", "SE", "Adj.SE")
> str(final_anc_ou_bio4)
'data.frame':	112 obs. of  7 variables:
 $ species       : Factor w/ 112 levels "Pinus_albicaulis",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ node_species  : int  1 2 3 4 5 6 7 8 9 10 ...
 $ current_value : num  8086 7405 8409 5290 6825 ...
 $ node_antecesor: int  121 127 143 162 127 175 134 142 197 126 ...
 $ ace           : num  6938 6811 6375 5701 6811 ...
 $ SE            : num  3230 2357 4379 1649 2357 ...
 $ Adj.SE        : num  703 691 617 690 691 ...
> head(final_anc_ou_bio4, 10)
             species node_species current_value node_antecesor     ace      SE
1   Pinus_albicaulis            1      8085.529            121 6937.89 3230.14
2     Pinus_amamiana            2      7404.947            127 6811.09 2357.09
3     Pinus_aristata            3      8409.148            143 6375.25 4379.43
4    Pinus_arizonica            4      5289.677            162 5700.70 1649.04
5     Pinus_armandii            5      6825.038            127 6811.09 2357.09
6    Pinus_attenuata            6      6299.891            175 6037.47 3834.49
7   Pinus_ayacahuite            7      1665.273            134 6051.70 2300.96
8  Pinus_balfouriana            8      6682.370            142 6303.68 4740.46
9    Pinus_banksiana            9     13275.060            197 6375.88 4950.87
10   Pinus_bhutanica           10      5084.777            126 6911.19 2348.02
   Adj.SE
1  703.15
2  690.77
3  616.96
4  690.23
5  690.77
6  622.15
7  886.43
8  567.73
9  562.63
10 719.97
> #bio17
> final_anc_ou_bio17 = final_anc_ou_bio17[,c(1,3,7,2,4,5,6)]
> colnames(final_anc_ou_bio17) <- c("species", "node_species", "current_value", "node_antecesor", "ace", "SE", "Adj.SE")
> str(final_anc_ou_bio17)
'data.frame':	112 obs. of  7 variables:
 $ species       : Factor w/ 112 levels "Pinus_albicaulis",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ node_species  : int  1 2 3 4 5 6 7 8 9 10 ...
 $ current_value : num  -228.8 116.7 -375 -340.4 -54.7 ...
 $ node_antecesor: int  121 127 143 162 127 175 134 142 197 126 ...
 $ ace           : num  -124 -85.1 -354.9 -340.4 -85.1 ...
 $ SE            : num  66.4 48.4 99.2 34.7 48.4 ...
 $ Adj.SE        : num  61.6 62.3 71.7 73 62.3 ...
> head(final_anc_ou_bio17, 10)
             species node_species current_value node_antecesor     ace     SE
1   Pinus_albicaulis            1    -228.83870            121 -123.96  66.41
2     Pinus_amamiana            2     116.73981            127  -85.10  48.44
3     Pinus_aristata            3    -375.01918            143 -354.88  99.15
4    Pinus_arizonica            4    -340.38992            162 -340.38  34.71
5     Pinus_armandii            5     -54.69776            127  -85.10  48.44
6    Pinus_attenuata            6    -415.81630            175 -271.54  80.60
7   Pinus_ayacahuite            7    -308.31137            134 -279.10  48.42
8  Pinus_balfouriana            8    -409.39973            142 -350.92 114.93
9    Pinus_banksiana            9     -90.18094            197 -143.99 128.81
10   Pinus_bhutanica           10     -65.66182            126  -88.55  46.35
   Adj.SE
1   61.60
2   62.26
3   71.74
4   73.00
5   62.26
6   72.25
7   79.06
8   62.60
9   73.94
10  56.97
> 
> #### bind final ramas with ancestral reconstructions from BM (ape) ####
> ##bio4
> #Bind node number,95CI and ace,
> final_anc_bm_bio4 = cbind.data.frame(row.names(pgls_recon_bio4$CI95), pgls_recon_bio4$ace, pgls_recon_bio4$CI95)
> colnames(final_anc_bm_bio4) <- c("nodo1", "State", "low_bound", "upper_bound")
> #merge anc data with species names
> final_anc_bm_bio4 = merge(final_ramas, final_anc_bm_bio4, by="nodo1")
> #reorder rows in basis on node numbers
> final_anc_bm_bio4 = final_anc_bm_bio4[order(final_anc_bm_bio4$nodo1, decreasing=FALSE),]
> #check that the anc data has been correctly extraced
> summary(final_anc_bm_bio4[which(!duplicated(final_anc_bm_bio4$nodo1)),c(5,6)] == pgls_recon_bio4$CI95[which(row.names(pgls_recon_bio4$CI95) %in% final_ramas$nodo1),])
 low_bound      upper_bound   
 Mode:logical   Mode:logical  
 TRUE:77        TRUE:77       
> #add current values
> final_anc_bm_bio4 = merge(final_anc_bm_bio4, climate_medians_merge_bio4, by="species_ramas")
> #check that current value is added correctly
> summary(climate_medians_merge[match(final_anc_bm_bio4$species_ramas, climate_medians_merge$species_ramas),]$species_ramas == final_anc_bm_bio4$species_ramas)
   Mode    TRUE 
logical     112 
> #reorder final data
> final_anc_bm_bio4 = final_anc_bm_bio4[,c(1,3,7,2,4,5,6)]
> colnames(final_anc_bm_bio4) = c("species", "node_species", "current_value", "node_antecesor", "ace", "ace_low_bound", "ace_upper_bound")
> str(final_anc_bm_bio4)
'data.frame':	112 obs. of  7 variables:
 $ species        : Factor w/ 112 levels "Pinus_albicaulis",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ node_species   : int  1 2 3 4 5 6 7 8 9 10 ...
 $ current_value  : num  8086 7405 8409 5290 6825 ...
 $ node_antecesor : int  121 127 143 162 127 175 134 142 197 126 ...
 $ ace            : num  8099 6601 7775 4691 6601 ...
 $ ace_low_bound  : num  8096 6599 7771 4690 6599 ...
 $ ace_upper_bound: num  8102 6603 7779 4693 6603 ...
> head(final_anc_bm_bio4, 20)
             species node_species current_value node_antecesor       ace
1   Pinus_albicaulis            1      8085.529            121  8098.962
2     Pinus_amamiana            2      7404.947            127  6601.172
3     Pinus_aristata            3      8409.148            143  7775.085
4    Pinus_arizonica            4      5289.677            162  4691.374
5     Pinus_armandii            5      6825.038            127  6601.172
6    Pinus_attenuata            6      6299.891            175  6112.516
7   Pinus_ayacahuite            7      1665.273            134  5011.948
8  Pinus_balfouriana            8      6682.370            142  7112.250
9    Pinus_banksiana            9     13275.060            197  8897.155
10   Pinus_bhutanica           10      5084.777            126  6021.156
11      Pinus_brutia           11      7489.295            203  6750.494
12    Pinus_bungeana           12      9328.577            139  8079.194
13 Pinus_canariensis           13      2849.534            206  5210.704
14    Pinus_caribaea           14      1473.654            183  3062.710
15      Pinus_cembra           15      7421.788            132 11599.971
16  Pinus_cembroides           16      5430.700            147  5773.154
17  Pinus_chiapensis           17      1675.613            136  5983.427
18      Pinus_clausa           18      5711.205            199  7684.115
19    Pinus_contorta           19      8963.001            199  7684.115
20     Pinus_cooperi           20      3940.676            162  4691.374
   ace_low_bound ace_upper_bound
1       8096.092        8101.831
2       6599.045        6603.299
3       7770.915        7779.254
4       4689.826        4692.922
5       6599.045        6603.299
6       6109.097        6115.935
7       5009.809        5014.086
8       7107.458        7117.042
9       8891.797        8902.513
10      6019.168        6023.143
11      6745.467        6755.522
12      8075.019        8083.369
13      5206.110        5215.299
14      3060.047        3065.374
15     11597.669       11602.273
16      5770.289        5776.020
17      5980.390        5986.465
18      7680.285        7687.946
19      7680.285        7687.946
20      4689.826        4692.922
> 
> ##bio17
> #Bind node number,95CI and ace,
> final_anc_bm_bio17 = cbind.data.frame(row.names(pgls_recon_bio17$CI95), pgls_recon_bio17$ace, pgls_recon_bio17$CI95)
> colnames(final_anc_bm_bio17) <- c("nodo1", "State", "low_bound", "upper_bound")
> #merge anc data with species names
> final_anc_bm_bio17 = merge(final_ramas, final_anc_bm_bio17, by="nodo1")
> #reorder rows in basis on node numbers
> final_anc_bm_bio17 = final_anc_bm_bio17[order(final_anc_bm_bio17$nodo1, decreasing=FALSE),]
> #check that the anc data has been correctly extraced
> summary(final_anc_bm_bio17[which(!duplicated(final_anc_bm_bio17$nodo1)),c(5,6)] == pgls_recon_bio17$CI95[which(row.names(pgls_recon_bio17$CI95) %in% final_ramas$nodo1),])
 low_bound      upper_bound   
 Mode:logical   Mode:logical  
 TRUE:77        TRUE:77       
> #add current values
> final_anc_bm_bio17 = merge(final_anc_bm_bio17, climate_medians_merge_bio17, by="species_ramas")
> #check that current value is added correctly
> summary(climate_medians_merge[match(final_anc_bm_bio17$species_ramas, climate_medians_merge$species_ramas),]$species_ramas == final_anc_bm_bio17$species_ramas)
   Mode    TRUE 
logical     112 
> #reorder final data
> final_anc_bm_bio17 = final_anc_bm_bio17[,c(1,3,7,2,4,5,6)]
> colnames(final_anc_bm_bio17) = c("species", "node_species", "current_value", "node_antecesor", "ace", "ace_low_bound", "ace_upper_bound")
> str(final_anc_bm_bio17)
'data.frame':	112 obs. of  7 variables:
 $ species        : Factor w/ 112 levels "Pinus_albicaulis",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ node_species   : int  1 2 3 4 5 6 7 8 9 10 ...
 $ current_value  : num  -228.8 116.7 -375 -340.4 -54.7 ...
 $ node_antecesor : int  121 127 143 162 127 175 134 142 197 126 ...
 $ ace            : num  -125.4 -13.8 -388.3 -340.4 -13.8 ...
 $ ace_low_bound  : num  -128.2 -15.9 -392.5 -341.9 -15.9 ...
 $ ace_upper_bound: num  -122.5 -11.7 -384.1 -338.8 -11.7 ...
> head(final_anc_bm_bio17, 20)
             species node_species current_value node_antecesor        ace
1   Pinus_albicaulis            1    -228.83870            121 -125.35051
2     Pinus_amamiana            2     116.73981            127  -13.79924
3     Pinus_aristata            3    -375.01918            143 -388.28339
4    Pinus_arizonica            4    -340.38992            162 -340.39426
5     Pinus_armandii            5     -54.69776            127  -13.79924
6    Pinus_attenuata            6    -415.81630            175 -299.44360
7   Pinus_ayacahuite            7    -308.31137            134 -311.85730
8  Pinus_balfouriana            8    -409.39973            142 -381.67253
9    Pinus_banksiana            9     -90.18094            197 -141.98092
10   Pinus_bhutanica           10     -65.66182            126  -64.39379
11      Pinus_brutia           11    -393.53844            203 -386.62772
12    Pinus_bungeana           12    -117.04013            139 -157.90941
13 Pinus_canariensis           13    -468.65808            206 -340.46636
14    Pinus_caribaea           14    -258.84024            183 -277.70110
15      Pinus_cembra           15     -53.85120            132  -82.83185
16  Pinus_cembroides           16    -339.95770            147 -332.75774
17  Pinus_chiapensis           17    -258.93489            136 -184.03899
18      Pinus_clausa           18    -115.22439            199 -125.27667
19    Pinus_contorta           19    -132.19698            199 -125.27667
20     Pinus_cooperi           20    -340.77664            162 -340.39426
   ace_low_bound ace_upper_bound
1     -128.21961      -122.48142
2      -15.92645       -11.67203
3     -392.45275      -384.11403
4     -341.94268      -338.84584
5      -15.92645       -11.67203
6     -302.86236      -296.02483
7     -313.99546      -309.71915
8     -386.46452      -376.88054
9     -147.33931      -136.62252
10     -66.38128       -62.40629
11    -391.65500      -381.60044
12    -162.08450      -153.73432
13    -345.06091      -335.87182
14    -280.36448      -275.03772
15     -85.13357       -80.53014
16    -335.62312      -329.89237
17    -187.07624      -181.00173
18    -129.10745      -121.44588
19    -129.10745      -121.44588
20    -341.94268      -338.84584
> 
> #### adittional check of correct selection of ancestral state per node #####
> ## bio4
> #BM
> raw_anc_bm_bio4 = pgls_recon_bio4$CI95[which(row.names(pgls_recon_bio4$CI95) %in% final_anc_bm_bio4$node_antecesor),] #select nodes of species from raw dataset
> test_results_anc_bm_bio4 = NULL
> test_results_current_bm_bio4 = NULL
> for(i in 1:length(final_anc_bm_bio4$species)){
+ 
+     #selected node
+     selected_species = final_anc_bm_bio4$species[i]
+ 
+     #select the row
+     selected_row_final_data = final_anc_bm_bio4[which(final_anc_bm_bio4$species == selected_species),]
+ 
+     #extract anc state from final data.set 
+     anc_final_dataset = selected_row_final_data[,which(colnames(final_anc_bm_bio4) %in% c("ace_low_bound", "ace_upper_bound"))]
+ 
+     #extract anc state from raw data.set     
+     anc_raw_dataset = raw_anc_bm_bio4[which(row.names(raw_anc_bm_bio4) == selected_row_final_data$node_antecesor),]
+ 
+     #test anc
+     test_results_anc_bm_bio4 = append(test_results_anc_bm_bio4, anc_final_dataset == anc_raw_dataset)
+ 
+     #extract current state from final data.set
+     current_final_dataset = selected_row_final_data[, which(colnames(final_anc_bm_bio4) %in% c("species", "current_value"))]
+     
+     #extract current state from raw data.set
+     current_raw_dataset = as.vector(bio4_vector[which(names(bio4_vector) == current_final_dataset$species)])
+ 
+     #test current state
+     test_results_current_bm_bio4 = append(test_results_current_bm_bio4, current_final_dataset$current_value == current_raw_dataset)
+ 
+ }
> length(test_results_anc_bm_bio4) == 112*2 #two limits per species (95CI of anc test)
[1] TRUE
> length(test_results_current_bm_bio4) == 112 #one current value per species
[1] TRUE
> 
> 
> #OU
> raw_anc_ou_bio4 = anc_ou_bio4[which(anc_ou_bio4$nodo1 %in% final_anc_ou_bio4$node_antecesor),] #select nodes of species from raw dataset
> test_results_anc_ou_bio4 = NULL
> test_results_current_ou_bio4 = NULL
> for(i in 1:length(final_anc_ou_bio4$species)){
+ 
+     #selected node
+     selected_species = final_anc_ou_bio4$species[i]
+ 
+     #select the row
+     selected_row_final_data = final_anc_ou_bio4[which(final_anc_ou_bio4$species == selected_species),]
+ 
+     #extract anc state from final data.set 
+     anc_final_dataset = selected_row_final_data[,which(colnames(final_anc_ou_bio4) %in% c("ace", "SE", "Adj.SE"))]
+ 
+     #extract anc state from raw data.set     
+     anc_raw_dataset = raw_anc_ou_bio4[which(raw_anc_ou_bio4$nodo1 == selected_row_final_data$node_antecesor), which(colnames(raw_anc_ou_bio4) %in% c("State", "SE", "Adj.SE"))]
+ 
+     #test anc
+     test_results_anc_ou_bio4 = append(test_results_anc_ou_bio4, anc_final_dataset == anc_raw_dataset)
+ 
+     #extract current state from final data.set
+     current_final_dataset = selected_row_final_data[, which(colnames(final_anc_ou_bio4) %in% c("species", "current_value"))]
+     
+     #extract current state from raw data.set
+     current_raw_dataset = as.vector(bio4_vector[which(names(bio4_vector) == current_final_dataset$species)])
+ 
+     #test current state
+     test_results_current_ou_bio4 = append(test_results_current_ou_bio4, current_final_dataset$current_value == current_raw_dataset)
+ 
+ }
> length(test_results_anc_ou_bio4) == 112*3 #two SE varaibles (SE and Adj.SE) per species and one ace (anc test)
[1] TRUE
> length(test_results_current_bm_bio4) == 112 #one current value per species
[1] TRUE
> 
> 
> ## bio17
> #BM
> raw_anc_bm_bio17 = pgls_recon_bio17$CI95[which(row.names(pgls_recon_bio17$CI95) %in% final_anc_bm_bio17$node_antecesor),] #select nodes of species from raw dataset
> test_results_anc_bm_bio17 = NULL
> test_results_current_bm_bio17 = NULL
> for(i in 1:length(final_anc_bm_bio17$species)){
+ 
+     #selected node
+     selected_species = final_anc_bm_bio17$species[i]
+ 
+     #select the row
+     selected_row_final_data = final_anc_bm_bio17[which(final_anc_bm_bio17$species == selected_species),]
+ 
+     #extract anc state from final data.set 
+     anc_final_dataset = selected_row_final_data[,which(colnames(final_anc_bm_bio17) %in% c("ace_low_bound", "ace_upper_bound"))]
+ 
+     #extract anc state from raw data.set     
+     anc_raw_dataset = raw_anc_bm_bio17[which(row.names(raw_anc_bm_bio17) == selected_row_final_data$node_antecesor),]
+ 
+     #test anc
+     test_results_anc_bm_bio17 = append(test_results_anc_bm_bio17, anc_final_dataset == anc_raw_dataset)
+ 
+     #extract current state from final data.set
+     current_final_dataset = selected_row_final_data[, which(colnames(final_anc_bm_bio17) %in% c("species", "current_value"))]
+     
+     #extract current state from raw data.set
+     current_raw_dataset = as.vector(bio17_vector[which(names(bio17_vector) == current_final_dataset$species)])
+ 
+     #test current state
+     test_results_current_bm_bio17 = append(test_results_current_bm_bio17, current_final_dataset$current_value == current_raw_dataset)
+ 
+ }
> length(test_results_anc_bm_bio17) == 112*2 #two limits per species (95CI of anc test)
[1] TRUE
> length(test_results_current_bm_bio17) == 112 #one current value per species
[1] TRUE
> 
> 
> #OU
> raw_anc_ou_bio17 = anc_ou_bio17[which(anc_ou_bio17$nodo1 %in% final_anc_ou_bio17$node_antecesor),] #select nodes of species from raw dataset
> test_results_anc_ou_bio17 = NULL
> test_results_current_ou_bio17 = NULL
> for(i in 1:length(final_anc_ou_bio17$species)){
+ 
+     #selected node
+     selected_species = final_anc_ou_bio17$species[i]
+ 
+     #select the row
+     selected_row_final_data = final_anc_ou_bio17[which(final_anc_ou_bio17$species == selected_species),]
+ 
+     #extract anc state from final data.set 
+     anc_final_dataset = selected_row_final_data[,which(colnames(final_anc_ou_bio17) %in% c("ace", "SE", "Adj.SE"))]
+ 
+     #extract anc state from raw data.set     
+     anc_raw_dataset = raw_anc_ou_bio17[which(raw_anc_ou_bio17$nodo1 == selected_row_final_data$node_antecesor), which(colnames(raw_anc_ou_bio17) %in% c("State", "SE", "Adj.SE"))]
+ 
+     #test anc
+     test_results_anc_ou_bio17 = append(test_results_anc_ou_bio17, anc_final_dataset == anc_raw_dataset)
+ 
+     #extract current state from final data.set
+     current_final_dataset = selected_row_final_data[, which(colnames(final_anc_ou_bio17) %in% c("species", "current_value"))]
+     
+     #extract current state from raw data.set
+     current_raw_dataset = as.vector(bio17_vector[which(names(bio17_vector) == current_final_dataset$species)])
+ 
+     #test current state
+     test_results_current_ou_bio17 = append(test_results_current_ou_bio17, current_final_dataset$current_value == current_raw_dataset)
+ 
+ }
> length(test_results_anc_ou_bio17) == 112*3 #two SE varaibles (SE and Adj.SE) per species and one ace (anc test)
[1] TRUE
> length(test_results_current_bm_bio17) == 112 #one current value per species
[1] TRUE
> 
> #summary
> summary(test_results_anc_bm_bio4)
   Mode    TRUE 
logical     224 
> summary(test_results_current_bm_bio4)
   Mode    TRUE 
logical     112 
> summary(test_results_anc_ou_bio4)
   Mode    TRUE 
logical     336 
> summary(test_results_current_bm_bio4)
   Mode    TRUE 
logical     112 
> summary(test_results_anc_bm_bio17)
   Mode    TRUE 
logical     224 
> summary(test_results_current_bm_bio17)
   Mode    TRUE 
logical     112 
> summary(test_results_anc_ou_bio17)
   Mode    TRUE 
logical     336 
> summary(test_results_current_bm_bio17) #ALL test correct, GO ON!
   Mode    TRUE 
logical     112 
> 
> #### Final dataset  ####
> str(final_anc_ou_bio4)
'data.frame':	112 obs. of  7 variables:
 $ species       : Factor w/ 112 levels "Pinus_albicaulis",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ node_species  : int  1 2 3 4 5 6 7 8 9 10 ...
 $ current_value : num  8086 7405 8409 5290 6825 ...
 $ node_antecesor: int  121 127 143 162 127 175 134 142 197 126 ...
 $ ace           : num  6938 6811 6375 5701 6811 ...
 $ SE            : num  3230 2357 4379 1649 2357 ...
 $ Adj.SE        : num  703 691 617 690 691 ...
> head(final_anc_ou_bio4, 20)
             species node_species current_value node_antecesor     ace      SE
1   Pinus_albicaulis            1      8085.529            121 6937.89 3230.14
2     Pinus_amamiana            2      7404.947            127 6811.09 2357.09
3     Pinus_aristata            3      8409.148            143 6375.25 4379.43
4    Pinus_arizonica            4      5289.677            162 5700.70 1649.04
5     Pinus_armandii            5      6825.038            127 6811.09 2357.09
6    Pinus_attenuata            6      6299.891            175 6037.47 3834.49
7   Pinus_ayacahuite            7      1665.273            134 6051.70 2300.96
8  Pinus_balfouriana            8      6682.370            142 6303.68 4740.46
9    Pinus_banksiana            9     13275.060            197 6375.88 4950.87
10   Pinus_bhutanica           10      5084.777            126 6911.19 2348.02
11      Pinus_brutia           11      7489.295            203 6244.75 4762.16
12    Pinus_bungeana           12      9328.577            139 6312.46 4380.82
13 Pinus_canariensis           13      2849.534            206 6180.85 4728.03
14    Pinus_caribaea           14      1473.654            183 4999.72 3157.55
15      Pinus_cembra           15      7421.788            132 7810.46 2604.88
16  Pinus_cembroides           16      5430.700            147 6197.04 3340.90
17  Pinus_chiapensis           17      1675.613            136 6241.60 3316.54
18      Pinus_clausa           18      5711.205            199 6355.03 4060.21
19    Pinus_contorta           19      8963.001            199 6355.03 4060.21
20     Pinus_cooperi           20      3940.676            162 5700.70 1649.04
   Adj.SE
1  703.15
2  690.77
3  616.96
4  690.23
5  690.77
6  622.15
7  886.43
8  567.73
9  562.63
10 719.97
11 616.72
12 553.38
13 548.07
14 785.22
15 877.94
16 645.89
17 745.62
18 585.02
19 585.02
20 690.23
> str(final_anc_ou_bio17)
'data.frame':	112 obs. of  7 variables:
 $ species       : Factor w/ 112 levels "Pinus_albicaulis",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ node_species  : int  1 2 3 4 5 6 7 8 9 10 ...
 $ current_value : num  -228.8 116.7 -375 -340.4 -54.7 ...
 $ node_antecesor: int  121 127 143 162 127 175 134 142 197 126 ...
 $ ace           : num  -124 -85.1 -354.9 -340.4 -85.1 ...
 $ SE            : num  66.4 48.4 99.2 34.7 48.4 ...
 $ Adj.SE        : num  61.6 62.3 71.7 73 62.3 ...
> head(final_anc_ou_bio17, 20)
             species node_species current_value node_antecesor     ace     SE
1   Pinus_albicaulis            1    -228.83870            121 -123.96  66.41
2     Pinus_amamiana            2     116.73981            127  -85.10  48.44
3     Pinus_aristata            3    -375.01918            143 -354.88  99.15
4    Pinus_arizonica            4    -340.38992            162 -340.38  34.71
5     Pinus_armandii            5     -54.69776            127  -85.10  48.44
6    Pinus_attenuata            6    -415.81630            175 -271.54  80.60
7   Pinus_ayacahuite            7    -308.31137            134 -279.10  48.42
8  Pinus_balfouriana            8    -409.39973            142 -350.92 114.93
9    Pinus_banksiana            9     -90.18094            197 -143.99 128.81
10   Pinus_bhutanica           10     -65.66182            126  -88.55  46.35
11      Pinus_brutia           11    -393.53844            203 -329.36 118.30
12    Pinus_bungeana           12    -117.04013            139 -179.39  99.11
13 Pinus_canariensis           13    -468.65808            206 -301.26 112.03
14    Pinus_caribaea           14    -258.84024            183 -256.37  62.52
15      Pinus_cembra           15     -53.85120            132  -83.13  52.94
16  Pinus_cembroides           16    -339.95770            147 -346.68  67.78
17  Pinus_chiapensis           17    -258.93489            136 -163.86  70.08
18      Pinus_clausa           18    -115.22439            199 -139.88  89.81
19    Pinus_contorta           19    -132.19698            199 -139.88  89.81
20     Pinus_cooperi           20    -340.77664            162 -340.38  34.71
   Adj.SE
1   61.60
2   62.26
3   71.74
4   73.00
5   62.26
6   72.25
7   79.06
8   62.60
9   73.94
10  56.97
11  65.70
12  62.55
13  57.82
14  54.15
15  82.17
16  70.57
17  94.25
18  81.10
19  81.10
20  73.00
> str(final_anc_bm_bio4)
'data.frame':	112 obs. of  7 variables:
 $ species        : Factor w/ 112 levels "Pinus_albicaulis",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ node_species   : int  1 2 3 4 5 6 7 8 9 10 ...
 $ current_value  : num  8086 7405 8409 5290 6825 ...
 $ node_antecesor : int  121 127 143 162 127 175 134 142 197 126 ...
 $ ace            : num  8099 6601 7775 4691 6601 ...
 $ ace_low_bound  : num  8096 6599 7771 4690 6599 ...
 $ ace_upper_bound: num  8102 6603 7779 4693 6603 ...
> head(final_anc_bm_bio4, 20)
             species node_species current_value node_antecesor       ace
1   Pinus_albicaulis            1      8085.529            121  8098.962
2     Pinus_amamiana            2      7404.947            127  6601.172
3     Pinus_aristata            3      8409.148            143  7775.085
4    Pinus_arizonica            4      5289.677            162  4691.374
5     Pinus_armandii            5      6825.038            127  6601.172
6    Pinus_attenuata            6      6299.891            175  6112.516
7   Pinus_ayacahuite            7      1665.273            134  5011.948
8  Pinus_balfouriana            8      6682.370            142  7112.250
9    Pinus_banksiana            9     13275.060            197  8897.155
10   Pinus_bhutanica           10      5084.777            126  6021.156
11      Pinus_brutia           11      7489.295            203  6750.494
12    Pinus_bungeana           12      9328.577            139  8079.194
13 Pinus_canariensis           13      2849.534            206  5210.704
14    Pinus_caribaea           14      1473.654            183  3062.710
15      Pinus_cembra           15      7421.788            132 11599.971
16  Pinus_cembroides           16      5430.700            147  5773.154
17  Pinus_chiapensis           17      1675.613            136  5983.427
18      Pinus_clausa           18      5711.205            199  7684.115
19    Pinus_contorta           19      8963.001            199  7684.115
20     Pinus_cooperi           20      3940.676            162  4691.374
   ace_low_bound ace_upper_bound
1       8096.092        8101.831
2       6599.045        6603.299
3       7770.915        7779.254
4       4689.826        4692.922
5       6599.045        6603.299
6       6109.097        6115.935
7       5009.809        5014.086
8       7107.458        7117.042
9       8891.797        8902.513
10      6019.168        6023.143
11      6745.467        6755.522
12      8075.019        8083.369
13      5206.110        5215.299
14      3060.047        3065.374
15     11597.669       11602.273
16      5770.289        5776.020
17      5980.390        5986.465
18      7680.285        7687.946
19      7680.285        7687.946
20      4689.826        4692.922
> str(final_anc_bm_bio17)
'data.frame':	112 obs. of  7 variables:
 $ species        : Factor w/ 112 levels "Pinus_albicaulis",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ node_species   : int  1 2 3 4 5 6 7 8 9 10 ...
 $ current_value  : num  -228.8 116.7 -375 -340.4 -54.7 ...
 $ node_antecesor : int  121 127 143 162 127 175 134 142 197 126 ...
 $ ace            : num  -125.4 -13.8 -388.3 -340.4 -13.8 ...
 $ ace_low_bound  : num  -128.2 -15.9 -392.5 -341.9 -15.9 ...
 $ ace_upper_bound: num  -122.5 -11.7 -384.1 -338.8 -11.7 ...
> head(final_anc_bm_bio17, 20)
             species node_species current_value node_antecesor        ace
1   Pinus_albicaulis            1    -228.83870            121 -125.35051
2     Pinus_amamiana            2     116.73981            127  -13.79924
3     Pinus_aristata            3    -375.01918            143 -388.28339
4    Pinus_arizonica            4    -340.38992            162 -340.39426
5     Pinus_armandii            5     -54.69776            127  -13.79924
6    Pinus_attenuata            6    -415.81630            175 -299.44360
7   Pinus_ayacahuite            7    -308.31137            134 -311.85730
8  Pinus_balfouriana            8    -409.39973            142 -381.67253
9    Pinus_banksiana            9     -90.18094            197 -141.98092
10   Pinus_bhutanica           10     -65.66182            126  -64.39379
11      Pinus_brutia           11    -393.53844            203 -386.62772
12    Pinus_bungeana           12    -117.04013            139 -157.90941
13 Pinus_canariensis           13    -468.65808            206 -340.46636
14    Pinus_caribaea           14    -258.84024            183 -277.70110
15      Pinus_cembra           15     -53.85120            132  -82.83185
16  Pinus_cembroides           16    -339.95770            147 -332.75774
17  Pinus_chiapensis           17    -258.93489            136 -184.03899
18      Pinus_clausa           18    -115.22439            199 -125.27667
19    Pinus_contorta           19    -132.19698            199 -125.27667
20     Pinus_cooperi           20    -340.77664            162 -340.39426
   ace_low_bound ace_upper_bound
1     -128.21961      -122.48142
2      -15.92645       -11.67203
3     -392.45275      -384.11403
4     -341.94268      -338.84584
5      -15.92645       -11.67203
6     -302.86236      -296.02483
7     -313.99546      -309.71915
8     -386.46452      -376.88054
9     -147.33931      -136.62252
10     -66.38128       -62.40629
11    -391.65500      -381.60044
12    -162.08450      -153.73432
13    -345.06091      -335.87182
14    -280.36448      -275.03772
15     -85.13357       -80.53014
16    -335.62312      -329.89237
17    -187.07624      -181.00173
18    -129.10745      -121.44588
19    -129.10745      -121.44588
20    -341.94268      -338.84584
> 
> ## save it
> write.table(final_anc_ou_bio4, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/final_recons/final_anc_ou_bio4.csv", sep=",", col.names = TRUE, row.names = FALSE)
> write.table(final_anc_ou_bio17, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/final_recons/final_anc_ou_bio17.csv", sep=",", col.names = TRUE, row.names = FALSE)
> write.table(final_anc_bm_bio4, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/final_recons/final_anc_bm_bio4.csv", sep=",", col.names = TRUE, row.names = FALSE)
> write.table(final_anc_bm_bio17, "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/final_recons/final_anc_bm_bio17.csv", sep=",", col.names = TRUE, row.names = FALSE)
> 
> ## NOTA: SI HUBIERA QUE COGER EL ESTADO ANCESTRAL EN UNA MISMA FECHA PARA TODAS LAS ESPECIES ANTES DEL ÚLTIMO NODO RESIVA LA FUNCIÓN CONTMAP DE PHYTOOLS, DE AHÍ PUEDES SACAR EL CÓDIGO PARA HACERLO. Mira en "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/code/phylo/contmap_phytools.R". Si no te aclaras mira este tutoria ("http://www.phytools.org/eqg/Exercise_5.2/"), la parte del traitgram. 
> 
> 
> #######################################################
> ################ EXAMPLE P.HALEPENSIS #################
> #######################################################
> 
> ###########################################################################
> ######### Extraction and preparation of climatic and species data #########
> ###########################################################################
> 
> #load packages
> library(raster)
> library(rgeos)
rgeos version: 0.3-26, (SVN revision 560)
 GEOS runtime version: 3.6.2-CAPI-1.10.2 4d2925d6 
 Linking to sp version: 1.2-5 
 Polygon checking: TRUE 

> 
> #set function to check if cell values is between ancestral and current value
> is.between <- function(cell_value, ancestral, current) {
+     
+     #empty vector to save results
+     result = NULL
+ 
+     #loop for extractinb results
+     for(v in 1:length(cell_value)){ #for each value of cell_value vector
+ 
+         #select the [v] cell_value
+         selected_value = cell_value[v]
+ 
+         #test if the [v] cell value is between ancestral an current values
+         test = (selected_value - ancestral)  *  (current - selected_value) #code taken from "https://stat.ethz.ch/pipermail/r-help/2008-August/170749.html". The order is irrelevant, ancestral can be higher or lower than current value. Idem for the sign of numbers, it works with only negative, only positive and negative-positive numbers.  
+  
+         #if test is not zero 
+         if(!test == 0){
+ 
+             #test if test is lower or higher than zero to know is the [v] cell value is between current and ancestral values. then save
+             result = append(result, test > 0)
+ 
+         } else { #if not, then [v] cell value is equal to the current or ancestral value, but we only want TRUE if the value is equal to the current value. 
+ 
+             #If the [v] cell value is equal to the current value
+             if(current == selected_value){
+ 
+                 #result is TRUE
+                 result = append(result, TRUE)
+             } else { #if not
+ 
+                 #if the [v] cell value is equal to ancestral value
+                 if(ancestral == selected_value){
+ 
+                     #result is FALSE
+                     result = append(result, FALSE)
+ 
+                 } else {
+ 
+                     #result is NA, problem
+                     result = append(result, NA)
+ 
+                 }
+             }
+         }
+     }
+ 
+     #return results
+     return(result)
+ } #Is very important to add ancestral first, and second current value, becuase TRUE will be returned if the cell_values is equal to "current" (second argument), but FALSE if it is equal to ancestral (first argument)
> 
> #set function to covert the suitibalityi phylo correct to a proportion from 0 to 1
> phylo_proportion = function(x, ancestral_value, current_value){
+ 
+     #calculate the maximum distance to the ancestal value (i.e the current value)
+     range_length = abs(current_value - ancestral_value)
+ 
+     #calculate between the cell value and the ancestral value
+     distance_to_ancestral = abs(x - ancestral_value)
+ 
+     #if range_length is the 1, distance_to_ancestral will be x; so x = (distance_to_ancestral*1)/range_length 
+     distance_to_ancestral/range_length
+ } #Like in the latter function, the order is key. The proportion will have 1 as value is close to the second argument (current value).
> 
> #load bio4 currently
> bio4 = raster("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/datos/phlyo/climatic_data_phylo/bio4.asc")
> res(bio4)
[1] 0.08333333 0.08333333
> 
> #load bio17 currently
> bio17 = raster("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/datos/phlyo/climatic_data_phylo/bio17.asc")
> res(bio17)
[1] 0.08333333 0.08333333
> 
> #plot bio4 and distribution polygons
> #plot(crop(bio4, polygon_plot_buffer))
> #plot(polygon_high_precision_points, lty=1, add=TRUE)
> #plot(ocurrences_buffer_polygon, lty=3, add=TRUE)
> 
> #plot bio17 and distribution polygons
> #plot(crop(bio17, polygon_plot_buffer))
> #plot(polygon_high_precision_points, lty=1, add=TRUE)
> #plot(ocurrences_buffer_polygon, lty=3, add=TRUE)
> 
> #list of continuos projections and binary projections for all scenarios and climatic models
> climatic_scenarios = c("bc26", "bc45", "bc60", "bc85", "cc26", "cc45", "cc60", "cc85", "gs26", "gs45", "gs60", "gs85", "he26", "he45", "he60", "he85", "ip26", "ip45", "ip60", "ip85", "mg26", "mg45", "mg60", "mg85", "mr26", "mr45", "mr60", "mr85")
> 
> #load projections of variables for all scenarios
> stack_bio17 = stack(paste("/Users/diegosalazar/phd_big_documents/pines_niche/climate_proj_phylo/bio17_", climatic_scenarios, ".asc", sep=""))
> stack_bio4 = stack(paste("/Users/diegosalazar/phd_big_documents/pines_niche/climate_proj_phylo/bio4_", climatic_scenarios, ".asc", sep=""))
> 
> ## load ancestral reconstruction
> final_anc_ou_bio4 = read.table("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/final_recons/final_anc_ou_bio4.csv", sep=",", header=TRUE)
> final_anc_ou_bio17 = read.table( "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/final_recons/final_anc_ou_bio17.csv", sep=",", header=TRUE)
> final_anc_bm_bio4 = read.table("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/final_recons/final_anc_bm_bio4.csv", sep=",", header=TRUE)
> final_anc_bm_bio17 = read.table( "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/final_recons/final_anc_bm_bio17.csv", sep=",", header=TRUE)
> 
> #take a look
> str(final_anc_ou_bio4)
'data.frame':	112 obs. of  7 variables:
 $ species       : Factor w/ 112 levels "Pinus_albicaulis",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ node_species  : int  1 2 3 4 5 6 7 8 9 10 ...
 $ current_value : num  8086 7405 8409 5290 6825 ...
 $ node_antecesor: int  121 127 143 162 127 175 134 142 197 126 ...
 $ ace           : num  6938 6811 6375 5701 6811 ...
 $ SE            : num  3230 2357 4379 1649 2357 ...
 $ Adj.SE        : num  703 691 617 690 691 ...
> str(final_anc_ou_bio17)
'data.frame':	112 obs. of  7 variables:
 $ species       : Factor w/ 112 levels "Pinus_albicaulis",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ node_species  : int  1 2 3 4 5 6 7 8 9 10 ...
 $ current_value : num  -228.8 116.7 -375 -340.4 -54.7 ...
 $ node_antecesor: int  121 127 143 162 127 175 134 142 197 126 ...
 $ ace           : num  -124 -85.1 -354.9 -340.4 -85.1 ...
 $ SE            : num  66.4 48.4 99.2 34.7 48.4 ...
 $ Adj.SE        : num  61.6 62.3 71.7 73 62.3 ...
> str(final_anc_bm_bio4)
'data.frame':	112 obs. of  7 variables:
 $ species        : Factor w/ 112 levels "Pinus_albicaulis",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ node_species   : int  1 2 3 4 5 6 7 8 9 10 ...
 $ current_value  : num  8086 7405 8409 5290 6825 ...
 $ node_antecesor : int  121 127 143 162 127 175 134 142 197 126 ...
 $ ace            : num  8099 6601 7775 4691 6601 ...
 $ ace_low_bound  : num  8096 6599 7771 4690 6599 ...
 $ ace_upper_bound: num  8102 6603 7779 4693 6603 ...
> str(final_anc_bm_bio17)
'data.frame':	112 obs. of  7 variables:
 $ species        : Factor w/ 112 levels "Pinus_albicaulis",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ node_species   : int  1 2 3 4 5 6 7 8 9 10 ...
 $ current_value  : num  -228.8 116.7 -375 -340.4 -54.7 ...
 $ node_antecesor : int  121 127 143 162 127 175 134 142 197 126 ...
 $ ace            : num  -125.4 -13.8 -388.3 -340.4 -13.8 ...
 $ ace_low_bound  : num  -128.2 -15.9 -392.5 -341.9 -15.9 ...
 $ ace_upper_bound: num  -122.5 -11.7 -384.1 -338.8 -11.7 ...
> 
> #list of evolution models: ONLY BM
> #list_models_bio4 = c("final_anc_ou_bio4", "final_anc_bm_bio4")
> #list_models_bio17 = c("final_anc_ou_bio17", "final_anc_bm_bio17")
> list_models_bio4 = c("final_anc_bm_bio4")
> list_models_bio17 = c("final_anc_bm_bio17")
> 
> #set the species
> species = "halepensis"
> 
> #load buffer of pseudo absences (broader) to crop climatic variables
> PA_buffer = raster(paste("/Users/diegosalazar/phd_big_documents/pines_niche/pa_buffers/", species, "_PA_buffer.asc", sep="")) #usamos PA buffer que es más amplio para la ver el rango filo por si salen sitios interesantes lejos para migración asistida, pero los plots en general se hacen con un area más pequeña. 
> 
> #crop climatic variables with PA buffer
> stack_bio17_cropped = crop(stack_bio17, PA_buffer)
> stack_bio4_cropped = crop(stack_bio4, PA_buffer)
> 
> #load species distribution (withput buffer)
> distri_raster = raster(paste("/Volumes/GoogleDrive/My Drive/science/phd/dispersal_heterogeneity/datos/DATOS/MAPS/p", paste(species, "01.img", sep="_"), sep="_"))
> 
> #create a polygon from distributon: DISTRIBUTION BUFFER USED INSTEAD OF THIS (see above)
> #distri_polygon = rasterToPolygons(distri_raster, fun=function(x){x==1}, n=16, dissolve=TRUE) #esta funcion de raster te transforma un raster completo o una parte del mismo en un poliogno. En nuestro caso solo queremos las celdas con valor=1, es decir, presencias. Por eso ponemos x==1. 
>     #dissolve = TRUE for dissolve limit inside the polygon, only external
> 
> #create a polygon from distributon + buffer
> ocurrences_buffer_path = unzip("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/ocurrences.zip",  list=FALSE, exdir = "/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/datos/phlyo/buffers", files = paste("ocurrences/", species, "_distribution_buffer.asc", sep=""), junkpaths = TRUE) #unzip species distribution with buffer
> ocurrences_buffer_raster = raster(ocurrences_buffer_path) #load it
> ocurrences_buffer_polygon = rasterToPolygons(ocurrences_buffer_raster, fun=function(x){x==1}, n=16, dissolve = TRUE) #convert to a polygon
> 
> #create a polygon buffer around the distribution buffer to reduce the area in plots
> polygon_plot_buffer = gBuffer(ocurrences_buffer_polygon, byid=FALSE, id=NULL, width=15, quadsegs=5, capStyle="ROUND", joinStyle="ROUND", mitreLimit=1.0) 
> 
> #create a raster from the plot buffer polygon 
> raster_plot_buffer = raster() 
> extent(raster_plot_buffer) = extent(distri_raster) 
> res(raster_plot_buffer) = res(distri_raster) 
> raster_plot_buffer  = rasterize(polygon_plot_buffer, raster_plot_buffer) 
> 
> #drop the sea areas
> raster_plot_buffer = distri_raster*raster_plot_buffer 
> raster_plot_buffer[!is.na(raster_plot_buffer)] <- 1 
> 
> #write the plot buffer without water bodies.  
> writeRaster(raster_plot_buffer, paste("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/plot_buffers", paste("final_figures", species, "plot_buffer.asc", sep="_"), sep="/"), format="ascii", overwrite=TRUE)
> 
> #load current suitability
> current_suit = raster(paste("/Users/diegosalazar/phd_big_documents/pines_niche/ensambles_final/ensamble_predictions_bin/ensamble_predictions_bin_", species, ".tif", sep=""))
> 
> #crop current suitability
> current_suit = crop(current_suit, polygon_plot_buffer)
> 
> #create a raster with acuatic bodies
> aquatic_bodies =  raster(extent(current_suit), resolution=res(current_suit))
> aquatic_bodies[which(is.na(getValues(current_suit)))] <- 1
> 
> #load ensamble of binary suitability
> projected_suit = raster(paste("/Users/diegosalazar/phd_big_documents/pines_niche/ensambles_final/ensamble_projections_bin/ensamble_projections_bin_", species, ".tif", sep=""))
> 
> #crop future sutiabiity aroun the whole PA buffer not for plotting but for analsis
> ensamble_suitability = crop(projected_suit, PA_buffer)
> 
> #crop projected suitability
> projected_suit = crop(projected_suit, polygon_plot_buffer)
> 
> #load ocurrences
> ocurrence_data = read.csv(paste("/Users/diegosalazar/phd_big_documents/pines_niche/ocurrences/", species, "_complete.presences.csv", sep=""), header=TRUE)
> 
> #subset high precision presences
> if(nrow(ocurrence_data[ocurrence_data$precision_weight==1,])>0){
+     high_precision_ocurrences = ocurrence_data[ocurrence_data$presence==1 & ocurrence_data$precision_weight==1,]
+ } else {
+     high_precision_ocurrences = data.frame()
+ }
> 
> #subset low precision presences
> if(nrow(ocurrence_data[ocurrence_data$precision_weight==0.5,])>0){
+     low_precision_ocurrences = ocurrence_data[ocurrence_data$presence==1 & ocurrence_data$precision_weight==0.5,]
+ } else {
+     low_precision_ocurrences = data.frame()
+ }
> 
> #create a spatial point data frame
> coors_high_precision_points = high_precision_ocurrences[,which(colnames(high_precision_ocurrences) %in% c("longitude", "latitude"))]
> coordinates(coors_high_precision_points) = c("longitude", "latitude")
> 
> #extrac id cells from that spatial point data frame
> id.cell <- extract(ocurrences_buffer_raster, coors_high_precision_points, cellnumbers=TRUE)[,1]
> 
> #create a polygon with those id cell, which will include all high precision points
> raster_high_precision_points = raster(extent(ocurrences_buffer_raster), resolution = res(ocurrences_buffer_raster)) #empty raster with the same extent and res than ocurrences_buffer_raster
> raster_high_precision_points[id.cell] <- ocurrences_buffer_raster[id.cell] #fill the raster with the values from the cells ocurrences_buffer_raster with presence of the species
> polygon_high_precision_points = rasterToPolygons(raster_high_precision_points, fun=function(x){x==1}, n=16, dissolve = TRUE) #convert to polygon
> 
> #loop for comparing projected climate and phylo range
> phylo_rasters_bio17 = stack()
> phylo_rasters_bio17_proportion = stack()
> for(s in 1:length(climatic_scenarios)){
+ 
+     #select the climatic scenario
+     selected_scenario = climatic_scenarios[s]
+ 
+     #create a empty raster with the same extent and resolution of the raster layer of the [s] IPCC scenario
+     raster_subsetted = raster(extent(stack_bio17_cropped[[s]]), resolution = res(stack_bio17_cropped[[s]]))
+ 
+     #add to the empty raster those cells of the [s] IPCC raster in which the habitat suitability is higher than 25 and lower than 75
+     raster_subsetted[which(getValues(ensamble_suitability) > 25 & getValues(ensamble_suitability) < 75)] <- stack_bio17_cropped[[s]][which(getValues(ensamble_suitability) > 25 & getValues(ensamble_suitability) < 75)] #suitability map has the same resolution and extent than IPCC maps because the suitability map was obtained from these raster of ICPP scenarios. 
+ 
+     #for each evolution model 
+     for(m in 1:length(list_models_bio17)){
+ 
+         #select the [m] evolution model 
+         selected_model = list_models_bio17[m]
+ 
+         #extract data of [m] model
+         model = get(selected_model)
+ 
+         #select the row of the corresponding species
+         model = model[which(model$species == paste("Pinus_", species, sep="")),]
+ 
+         #extract all cell values from the raster with climatic data of the [s] scenario only in those areas with uncertainty (raster_subsetted)
+         cell_values = getValues(raster_subsetted)
+ 
+         #extract ID of those cells without NA
+         cells_withot_NA = which(!is.na(cell_values))
+ 
+         #extract, from all cells withput NA, those whose value is inside the phylogenetic range (including the current value but not including the ancestral). For that we used is.between function, created by me. 
+         cell_inside_phylo_range = which(is.between(cell_value = na.omit(getValues(raster_subsetted)), ancestral = model$ace, current = model$current_value))
+ 
+         #from ID of cells without NA, select the ID of those whose vale is inside of the phylo range
+         final_cells = cells_withot_NA[cell_inside_phylo_range]
+ 
+         #create a empty raster with the same extent and resolution than the [s] IPCC raster
+         final_raster = raster(extent(stack_bio17_cropped[[s]]), resolution = res(stack_bio17_cropped[[s]]))
+         final_raster_proportion = raster(extent(stack_bio17_cropped[[s]]), resolution = res(stack_bio17_cropped[[s]]))
+ 
+         #fill the raster with zeros
+         final_raster[] <- 0
+         final_raster_proportion[] <- 0
+ 
+         #add to these final cells a value of suitability without and with proportion
+         final_raster[final_cells] <- 1
+         final_raster_proportion[final_cells] <- phylo_proportion(x=raster_subsetted[final_cells], ancestral_value=model$ace, current_value=model$current_value)
+ 
+         #add the name of the raster
+         names(final_raster) <- paste(selected_scenario, "_", strsplit(selected_model, split="_")[[1]][3], "_", strsplit(selected_model, split="_")[[1]][4], sep="")
+         names(final_raster_proportion) <- paste(selected_scenario, "_", strsplit(selected_model, split="_")[[1]][3], "_", strsplit(selected_model, split="_")[[1]][4], sep="")        
+ 
+         #save the raster into a stack
+         phylo_rasters_bio17 = stack(phylo_rasters_bio17, final_raster)
+         phylo_rasters_bio17_proportion = stack(phylo_rasters_bio17_proportion, final_raster_proportion)
+     }    
+ }
> 
> #check that all scenarios has been included
> nlayers(phylo_rasters_bio17) == length(climatic_scenarios)
[1] TRUE
> nlayers(phylo_rasters_bio17_proportion) == length(climatic_scenarios)
[1] TRUE
> 
> #sum suitability across IPCC scenarios for bio17
> sum_phylo_bio17 = calc(phylo_rasters_bio17, function(x) (sum(x)))
> 
> #loop for comparing projected climate and phylo range
> phylo_rasters_bio4 = stack()
> phylo_rasters_bio4_proportion = stack()
> for(s in 1:length(climatic_scenarios)){
+ 
+     #select the climatic scenario
+     selected_scenario = climatic_scenarios[s]
+ 
+     #create a empty raster with the same extent and resolution of the raster layer of the [s] IPCC scenario
+     raster_subsetted = raster(extent(stack_bio4_cropped[[s]]), resolution = res(stack_bio4_cropped[[s]]))
+ 
+     #add to the empty raster those cells of the [s] IPCC raster in which the habitat suitability is higher than 25 and lower than 75
+     raster_subsetted[which(getValues(ensamble_suitability) > 25 & getValues(ensamble_suitability) < 75)] <- stack_bio4_cropped[[s]][which(getValues(ensamble_suitability) > 25 & getValues(ensamble_suitability) < 75)] #suitability map has the same resolution and extent than IPCC maps because the suitability map was obtained from these raster of ICPP scenarios. 
+ 
+     #for each evolution model 
+     for(m in 1:length(list_models_bio4)){
+ 
+         #select the [m] evolution model 
+         selected_model = list_models_bio4[m]
+ 
+         #extract data of [m] model
+         model = get(selected_model)
+ 
+         #select the row of the corresponding species
+         model = model[which(model$species == paste("Pinus_", species, sep="")),]
+ 
+         #extract all cell values from the raster with climatic data of the [s] scenario only in those areas with uncertainty (raster_subsetted)
+         cell_values = getValues(raster_subsetted)
+ 
+         #extract ID of those cells without NA
+         cells_withot_NA = which(!is.na(cell_values))
+ 
+         #extract, from all cells withput NA, those whose value is inside the phylogenetic range (including the current value but not including the ancestral). For that we used is.between function, created by me. 
+         cell_inside_phylo_range = which(is.between(cell_value = na.omit(getValues(raster_subsetted)), ancestral = model$ace, current = model$current_value))
+ 
+         #from ID of cells without NA, select the ID of those whose vale is inside of the phylo range
+         final_cells = cells_withot_NA[cell_inside_phylo_range]
+ 
+         #create a empty raster with the same extent and resolution than the [s] IPCC raster
+         final_raster = raster(extent(stack_bio4_cropped[[s]]), resolution = res(stack_bio4_cropped[[s]]))
+         final_raster_proportion = raster(extent(stack_bio4_cropped[[s]]), resolution = res(stack_bio4_cropped[[s]]))
+ 
+         #fill the raster with zeros
+         final_raster[] <- 0
+         final_raster_proportion[] <- 0
+ 
+         #add to these final cells a value of suitability without and with proportion
+         final_raster[final_cells] <- 1
+         final_raster_proportion[final_cells] <- phylo_proportion(x=raster_subsetted[final_cells], ancestral_value=model$ace, current_value=model$current_value)
+ 
+         #add the name of the raster
+         names(final_raster) <- paste(selected_scenario, "_", strsplit(selected_model, split="_")[[1]][3], "_", strsplit(selected_model, split="_")[[1]][4], sep="")
+         names(final_raster_proportion) <- paste(selected_scenario, "_", strsplit(selected_model, split="_")[[1]][3], "_", strsplit(selected_model, split="_")[[1]][4], sep="")        
+ 
+         #save the raster into a stack
+         phylo_rasters_bio4 = stack(phylo_rasters_bio4, final_raster)
+         phylo_rasters_bio4_proportion = stack(phylo_rasters_bio4_proportion, final_raster_proportion)
+     }    
+ }
> 
> #check that all scenarios has been included
> nlayers(phylo_rasters_bio4) == length(climatic_scenarios)
[1] TRUE
> nlayers(phylo_rasters_bio4_proportion) == length(climatic_scenarios)
[1] TRUE
> 
> #sum suitability across IPCC scenarios for bio4
> sum_phylo_bio4 = calc(phylo_rasters_bio4, function(x) (sum(x)))
> 
> #calculate intersection between sum both suitaiblity maps (bio17, bio4)
> intersection_ensamble_phylo = sum_phylo_bio17 * sum_phylo_bio4 #this will be used to exclude areas not shared between variables from the final ensamble. 
> 
> #bind bio4 and bio17 rasters without proportions
> phylo_rasters = stack(phylo_rasters_bio4, phylo_rasters_bio17)
> nlayers(phylo_rasters) == length(climatic_scenarios)*2
[1] TRUE
> 
> #bind bio4 and bio17 rasters with proportions
> phylo_rasters_proportion = stack(phylo_rasters_bio4_proportion, phylo_rasters_bio17_proportion)
> nlayers(phylo_rasters_proportion) == length(climatic_scenarios)*2
[1] TRUE
> 
> #calculate the proportion of cells that fall inside the differents phylo ranges across IPCC scenarios and global circulation models without and with proportions
> ensamble_phylo = calc(phylo_rasters, function(x) (sum(x)*0.5)/nlayers(phylo_rasters)) #En tanto por 0.5, para luego sumarle 0.5 y que todos los valores estén por encima de 0.5. Así ganamos contraste y los mapas son comparables entre especies. 
> ensamble_phylo_proportion = calc(phylo_rasters_proportion, function(x) (sum(x)*0.5)/nlayers(phylo_rasters_proportion)) #En tanto por 0.5, para luego sumarle 0.5 y que todos los valores estén por encima de 0.5. Así ganamos contraste y los mapas son comparables entre especies. 
> 
> #sumamos 0.5 para tener valores de idoneidad de 0.5 a 1 (mayor contraste)
> ensamble_phylo = calc(ensamble_phylo, function(x) (x+0.5))
> ensamble_phylo_proportion = calc(ensamble_phylo_proportion, function(x) (x+0.5))
> 
> #ponemos como cero los casos con el valor mínimo (sería el 0 en el raster inicial antes de sumar), para que así queden transparentes
> second_ensamble_phylo = ensamble_phylo
> second_ensamble_phylo[which(getValues(second_ensamble_phylo) == min(getValues(second_ensamble_phylo)))] <- 0
> second_ensamble_phylo_proportion = ensamble_phylo_proportion
> second_ensamble_phylo_proportion[which(getValues(second_ensamble_phylo_proportion) == min(getValues(second_ensamble_phylo_proportion)))] <- 0
> 
> #check that raster withput proportians has a equal or higher suitability than the raster with proportions
> median(getValues(second_ensamble_phylo)[which(!getValues(second_ensamble_phylo)==0)]) >= median(getValues(second_ensamble_phylo_proportion)[which(!getValues(second_ensamble_phylo_proportion)==0)])
[1] TRUE
> 
> #select only those areas suitable for at least one scenario for each variables in the suitability without proportions
> #bio17 and bio4 suitaiblity don't overlap in areas with zero in intersection_ensamble_phylo
> second_ensamble_phylo[intersection_ensamble_phylo == 0] <- 0
> second_ensamble_phylo_proportion[intersection_ensamble_phylo == 0] <- 0
> 
> #save second ensables
> writeRaster(second_ensamble_phylo, paste("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/final_figures/phylo_ensamble/without_proportions/", species, "_phylo_ensamble_without_proportions.asc", sep=""), overwrite=TRUE)
> writeRaster(second_ensamble_phylo_proportion, paste("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/final_figures/phylo_ensamble/with_proportions/", species, "_phylo_ensamble_with_proportions.asc", sep=""), overwrite=TRUE)
> 
> #creamos un raster con todas las áreas que caen en algún ranog filo para algún escenario para el raster sin proporciones. PARA plotear
> final_ensamble_phylo = raster(extent(second_ensamble_phylo), resolution = res(second_ensamble_phylo))
> final_ensamble_phylo[]<-0
> final_ensamble_phylo[which(getValues(second_ensamble_phylo) > 0)] <- 1
> 
> #creamos un raster con todas las áreas que caen en algún ranog filo para algún escenario para el raster sin proporciones. PARA plotear. 
> final_ensamble_phylo_proportion = raster(extent(second_ensamble_phylo_proportion), resolution = res(second_ensamble_phylo_proportion))
> final_ensamble_phylo_proportion[]<-0
> final_ensamble_phylo_proportion[which(getValues(second_ensamble_phylo_proportion) > 0)] <- 1
> 
> ###plot final con todos los paneles sin usar proporciones
> #ploteamos seas áreas sonbre la idoneidad de hábitat, pero con un nivel de transparencia dependiente del número casos en los que la celda ha caído dentro del rango filo (incertidumbre; alpha=second_ensamble_phylo). Por tanto, aquellas zonas que han caído dentro del rango para pocos scenarios ó solo para una de las varuables se ven poco (podría verse con solo una variable dentro del rango sin entrease en el rango bajo muuuchos escenarios).
> pdf(paste("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/final_figures/suple/without_proportions/", species, "_without_proportions.pdf", sep=""), width=12, height = 12)
> par(oma=c(0,0,2.7,2))
> par(mfcol=c(2,2))
> 
> ###Pannel 1
> plot(current_suit,  main="", axis.args=list(cex.axis=1.5))
> mtext(text="Predicted habitat suitability currently", side=3,line=2, outer=FALSE, cex=1.4, font = 2)
> #add acuatic bodies
> plot(aquatic_bodies, col = "steelblue2", add=TRUE, legend=FALSE)
> #plot low precision points
> if(nrow(low_precision_ocurrences)>0){
+     points(low_precision_ocurrences$longitude, low_precision_ocurrences$latitude, cex=0.5, col="white", bg=NA, lwd=0.6, type="p", pch=21)
+ }
> #plot high precision points
> if(nrow(high_precision_ocurrences)>0){
+     points(high_precision_ocurrences$longitude, high_precision_ocurrences$latitude, cex=0.5, col="black", bg=NA, lwd=0.2, type="p", pch=21)
+ } 
> #plot the legend    
> legend("top", legend=c("High precision points", "Low precision points"), fill=c("black", "white"), cex=1.25, bty="o", horiz=TRUE, bg="white")
> 
> ###Pannel 2
> plot(current_suit,  main="", axis.args=list(cex.axis=1.5))
> mtext(text="Predicted habitat suitability currently", side=3,line=2, outer=FALSE, cex=1.4, font = 2)
> #add acuatic bodies
> plot(aquatic_bodies, col = "steelblue2", add=TRUE, legend=FALSE)
> #add lines around high precision points
> plot(polygon_high_precision_points, lty=1, add=TRUE, lwd=2)
> #add polygon of cirtifield distribution + buffer
> plot(ocurrences_buffer_polygon, lty=3, add=TRUE, lwd=2)
> #plot the legend    
> legend("top", legend=c("High precision points", "Low precision points"), lty=c(1,3), cex=1.25, bty="o", lwd=2, horiz=TRUE, bg="white")
> 
> ###Pannel 3
> plot(projected_suit, main="", , axis.args=list(cex.axis=1.5))
> mtext(text="Predicted habitat suitability in 2070", side=3,line=2, outer=FALSE, cex=1.4, font = 2)
> #add acuatic bodies
> plot(aquatic_bodies, col = "steelblue2", add=TRUE, legend=FALSE)
> #add lines around high precision points
> plot(polygon_high_precision_points, lty=1, add=TRUE, lwd=2)
> #add polygon of cirtifield distribution + buffer
> plot(ocurrences_buffer_polygon, lty=3, add=TRUE, lwd=2)
> #plot the legend    
> legend("top", legend=c("High precision points", "Low precision points"), lty=c(1,3), cex=1.25, bty="o", lwd=2, horiz=TRUE, bg="white")
> 
> ###Pannel 4
> plot(projected_suit, main="", axis.args=list(cex.axis=1.5))
> mtext(text="Predicted habitat suitability in 2070", side=3, line=3, outer=FALSE, cex=1.4, font = 2)
> mtext(text="+", side=3,line=2.2, outer=FALSE, cex=1, font = 2)
> mtext(text="Phylo-corrected suitability", side=3,line=1, outer=FALSE, cex=1.4, font = 2)
> #add acuatic bodies
> plot(aquatic_bodies, col = "steelblue2", add=TRUE, legend=FALSE)
> #add lines around high precision points
> plot(polygon_high_precision_points, lty=1, add=TRUE, lwd=2)
> #add polygon of cirtifield distribution + buffer
> plot(ocurrences_buffer_polygon, lty=3, add=TRUE, lwd=2)
> #add info phlo
> plot(final_ensamble_phylo, col="#00ffe9", alpha=second_ensamble_phylo, add=TRUE, legend=FALSE) 
>     #col="#0000FF": color azul oscuro; ALTERNATIVA el negro ("#0000FF"). 
>     #alpha=second_ensamble_phylo: transparencia dependiente de la incertidumbre (número casos en los que la celda ha caído dentro del rango filo)
>     #add=TRUE: Add to the previous plot
>     #legend=FALSE: Not add legend, in that way the legen of the first plot will not be hidden
> #plot the legend of precision    
> legend("top", legend=c("High precision points", "Low precision points"), lty=c(1,3), cex=1.25, bty="o", lwd=2, horiz=TRUE, bg="white")
> #add legend of acnestral
> legend("bottom", legend="Phylo-corrected suitability", fill="#00ffe9", bty="o", cex=1.25, bg="white")
> 
> #### main title
> title("") #this is used because mtext only does not work (see http://stackoverflow.com/questions/12895783/r-language-mtext-not-working-with-image-plot-array)
> mtext(bquote(italic('Pinus') ~italic(.(species))), outer = TRUE, cex = 2.5, font=2) #bquote is used to convert to italic the specific epithet (see http://stackoverflow.com/questions/27266398/using-italics-in-the-title-on-an-object-from-a-dataframe)
> dev.off()
pdf 
  2 
> 
> ###plot final con todos los paneles con proporciones
> #ploteamos seas áreas sonbre la idoneidad de hábitat, pero con un nivel de transparencia dependiente del número casos en los que la celda ha caído dentro del rango filo (incertidumbre; alpha=second_ensamble_phylo). Por tanto, aquellas zonas que han caído dentro del rango para pocos scenarios ó solo para una de las varuables se ven poco (podría verse con solo una variable dentro del rango sin entrease en el rango bajo muuuchos escenarios).
> pdf(paste("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/final_figures/suple/with_proportions/", species, "_with_proportions.pdf", sep=""), width=12, height = 12)
> par(oma=c(0,0,2.7,2))
> par(mfcol=c(2,2))
> 
> ###Pannel 1
> plot(current_suit,  main="", axis.args=list(cex.axis=1.5))
> mtext(text="Predicted habitat suitability currently", side=3,line=2, outer=FALSE, cex=1.4, font = 2)
> #add acuatic bodies
> plot(aquatic_bodies, col = "steelblue2", add=TRUE, legend=FALSE)
> #plot low precision points
> if(nrow(low_precision_ocurrences)>0){
+     points(low_precision_ocurrences$longitude, low_precision_ocurrences$latitude, cex=0.5, col="white", bg=NA, lwd=0.6, type="p", pch=21)
+ }
> #plot high precision points
> if(nrow(high_precision_ocurrences)>0){
+     points(high_precision_ocurrences$longitude, high_precision_ocurrences$latitude, cex=0.5, col="black", bg=NA, lwd=0.2, type="p", pch=21)
+ } 
> #plot the legend    
> legend("top", legend=c("High precision points", "Low precision points"), fill=c("black", "white"), cex=1.25, bty="o", horiz=TRUE, bg="white")
> 
> ###Pannel 2
> plot(current_suit,  main="", axis.args=list(cex.axis=1.5))
> mtext(text="Predicted habitat suitability currently", side=3,line=2, outer=FALSE, cex=1.4, font = 2)
> #add acuatic bodies
> plot(aquatic_bodies, col = "steelblue2", add=TRUE, legend=FALSE)
> #add lines around high precision points
> plot(polygon_high_precision_points, lty=1, add=TRUE, lwd=2)
> #add polygon of cirtifield distribution + buffer
> plot(ocurrences_buffer_polygon, lty=3, add=TRUE, lwd=2)
> #plot the legend    
> legend("top", legend=c("High precision points", "Low precision points"), lty=c(1,3), cex=1.25, bty="o", lwd=2, horiz=TRUE, bg="white")
> 
> ###Pannel 3
> plot(projected_suit, main="", , axis.args=list(cex.axis=1.5))
> mtext(text="Predicted habitat suitability in 2070", side=3,line=2, outer=FALSE, cex=1.4, font = 2)
> #add acuatic bodies
> plot(aquatic_bodies, col = "steelblue2", add=TRUE, legend=FALSE)
> #add lines around high precision points
> plot(polygon_high_precision_points, lty=1, add=TRUE, lwd=2)
> #add polygon of cirtifield distribution + buffer
> plot(ocurrences_buffer_polygon, lty=3, add=TRUE, lwd=2)
> #plot the legend    
> legend("top", legend=c("High precision points", "Low precision points"), lty=c(1,3), cex=1.25, bty="o", lwd=2, horiz=TRUE, bg="white")
> 
> ###Pannel 4
> plot(projected_suit, main="", axis.args=list(cex.axis=1.5))
> mtext(text="Predicted habitat suitability in 2070", side=3, line=3, outer=FALSE, cex=1.4, font = 2)
> mtext(text="+", side=3,line=2.2, outer=FALSE, cex=1, font = 2)
> mtext(text="Phylo-corrected suitability", side=3,line=1, outer=FALSE, cex=1.4, font = 2)
> #add acuatic bodies
> plot(aquatic_bodies, col = "steelblue2", add=TRUE, legend=FALSE)
> #add lines around high precision points
> plot(polygon_high_precision_points, lty=1, add=TRUE, lwd=2)
> #add polygon of cirtifield distribution + buffer
> plot(ocurrences_buffer_polygon, lty=3, add=TRUE, lwd=2)
> #add info phlo
> plot(final_ensamble_phylo_proportion, col="#00ffe9", alpha=second_ensamble_phylo_proportion, add=TRUE, legend=FALSE) 
>     #col="#0000FF": color azul oscuro; ALTERNATIVA el negro ("#0000FF"). 
>     #alpha=second_ensamble_phylo: transparencia dependiente de la incertidumbre (número casos en los que la celda ha caído dentro del rango filo)
>     #add=TRUE: Add to the previous plot
>     #legend=FALSE: Not add legend, in that way the legen of the first plot will not be hidden
> #plot the legend of precision    
> legend("top", legend=c("High precision points", "Low precision points"), lty=c(1,3), cex=1.25, bty="o", lwd=2, horiz=TRUE, bg="white")
> #add legend of acnestral
> legend("bottom", legend="Phylo-corrected suitability", fill="#00ffe9", bty="o", cex=1.25, bg="white")
> 
> #### main title
> title("") #this is used because mtext only does not work (see http://stackoverflow.com/questions/12895783/r-language-mtext-not-working-with-image-plot-array)
> mtext(bquote(italic('Pinus') ~italic(.(species))), outer = TRUE, cex = 2.5, font=2) #bquote is used to convert to italic the specific epithet (see http://stackoverflow.com/questions/27266398/using-italics-in-the-title-on-an-object-from-a-dataframe)
> dev.off()
pdf 
  2 
> 
> #save image
> save.image("/Volumes/GoogleDrive/My Drive/science/phd/nicho_pinus/results/phylo_reconstruction/rdata/tests_phylo.RData")
> 
> proc.time()
    user   system  elapsed 
2330.473  159.702 2350.279 
